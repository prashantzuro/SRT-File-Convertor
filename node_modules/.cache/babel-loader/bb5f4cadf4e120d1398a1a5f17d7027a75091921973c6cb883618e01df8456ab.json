{"ast":null,"code":"var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _MessageStream_instances, _MessageStream_currentMessageSnapshot, _MessageStream_connectedPromise, _MessageStream_resolveConnectedPromise, _MessageStream_rejectConnectedPromise, _MessageStream_endPromise, _MessageStream_resolveEndPromise, _MessageStream_rejectEndPromise, _MessageStream_listeners, _MessageStream_ended, _MessageStream_errored, _MessageStream_aborted, _MessageStream_catchingPromiseCreated, _MessageStream_getFinalMessage, _MessageStream_getFinalText, _MessageStream_handleError, _MessageStream_beginRequest, _MessageStream_addStreamEvent, _MessageStream_endRequest, _MessageStream_accumulateMessage;\nimport { AnthropicError, APIUserAbortError } from '@anthropic-ai/sdk/error';\nimport { Stream } from '@anthropic-ai/sdk/streaming';\nimport { partialParse } from \"../_vendor/partial-json-parser/parser.mjs\";\nconst JSON_BUF_PROPERTY = '__json_buf';\nexport class MessageStream {\n  constructor() {\n    _MessageStream_instances.add(this);\n    this.messages = [];\n    this.receivedMessages = [];\n    _MessageStream_currentMessageSnapshot.set(this, void 0);\n    this.controller = new AbortController();\n    _MessageStream_connectedPromise.set(this, void 0);\n    _MessageStream_resolveConnectedPromise.set(this, () => {});\n    _MessageStream_rejectConnectedPromise.set(this, () => {});\n    _MessageStream_endPromise.set(this, void 0);\n    _MessageStream_resolveEndPromise.set(this, () => {});\n    _MessageStream_rejectEndPromise.set(this, () => {});\n    _MessageStream_listeners.set(this, {});\n    _MessageStream_ended.set(this, false);\n    _MessageStream_errored.set(this, false);\n    _MessageStream_aborted.set(this, false);\n    _MessageStream_catchingPromiseCreated.set(this, false);\n    _MessageStream_handleError.set(this, error => {\n      __classPrivateFieldSet(this, _MessageStream_errored, true, \"f\");\n      if (error instanceof Error && error.name === 'AbortError') {\n        error = new APIUserAbortError();\n      }\n      if (error instanceof APIUserAbortError) {\n        __classPrivateFieldSet(this, _MessageStream_aborted, true, \"f\");\n        return this._emit('abort', error);\n      }\n      if (error instanceof AnthropicError) {\n        return this._emit('error', error);\n      }\n      if (error instanceof Error) {\n        const anthropicError = new AnthropicError(error.message);\n        // @ts-ignore\n        anthropicError.cause = error;\n        return this._emit('error', anthropicError);\n      }\n      return this._emit('error', new AnthropicError(String(error)));\n    });\n    __classPrivateFieldSet(this, _MessageStream_connectedPromise, new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _MessageStream_resolveConnectedPromise, resolve, \"f\");\n      __classPrivateFieldSet(this, _MessageStream_rejectConnectedPromise, reject, \"f\");\n    }), \"f\");\n    __classPrivateFieldSet(this, _MessageStream_endPromise, new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _MessageStream_resolveEndPromise, resolve, \"f\");\n      __classPrivateFieldSet(this, _MessageStream_rejectEndPromise, reject, \"f\");\n    }), \"f\");\n    // Don't let these promises cause unhandled rejection errors.\n    // we will manually cause an unhandled rejection error later\n    // if the user hasn't registered any error listener or called\n    // any promise-returning method.\n    __classPrivateFieldGet(this, _MessageStream_connectedPromise, \"f\").catch(() => {});\n    __classPrivateFieldGet(this, _MessageStream_endPromise, \"f\").catch(() => {});\n  }\n  /**\n   * Intended for use on the frontend, consuming a stream produced with\n   * `.toReadableStream()` on the backend.\n   *\n   * Note that messages sent to the model do not appear in `.on('message')`\n   * in this context.\n   */\n  static fromReadableStream(stream) {\n    const runner = new MessageStream();\n    runner._run(() => runner._fromReadableStream(stream));\n    return runner;\n  }\n  static createMessage(messages, params, options) {\n    const runner = new MessageStream();\n    for (const message of params.messages) {\n      runner._addMessageParam(message);\n    }\n    runner._run(() => runner._createMessage(messages, {\n      ...params,\n      stream: true\n    }, {\n      ...options,\n      headers: {\n        ...options?.headers,\n        'X-Stainless-Helper-Method': 'stream'\n      }\n    }));\n    return runner;\n  }\n  _run(executor) {\n    executor().then(() => {\n      this._emitFinal();\n      this._emit('end');\n    }, __classPrivateFieldGet(this, _MessageStream_handleError, \"f\"));\n  }\n  _addMessageParam(message) {\n    this.messages.push(message);\n  }\n  _addMessage(message, emit = true) {\n    this.receivedMessages.push(message);\n    if (emit) {\n      this._emit('message', message);\n    }\n  }\n  async _createMessage(messages, params, options) {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_beginRequest).call(this);\n    const stream = await messages.create({\n      ...params,\n      stream: true\n    }, {\n      ...options,\n      signal: this.controller.signal\n    });\n    this._connected();\n    for await (const event of stream) {\n      __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_addStreamEvent).call(this, event);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_endRequest).call(this);\n  }\n  _connected() {\n    if (this.ended) return;\n    __classPrivateFieldGet(this, _MessageStream_resolveConnectedPromise, \"f\").call(this);\n    this._emit('connect');\n  }\n  get ended() {\n    return __classPrivateFieldGet(this, _MessageStream_ended, \"f\");\n  }\n  get errored() {\n    return __classPrivateFieldGet(this, _MessageStream_errored, \"f\");\n  }\n  get aborted() {\n    return __classPrivateFieldGet(this, _MessageStream_aborted, \"f\");\n  }\n  abort() {\n    this.controller.abort();\n  }\n  /**\n   * Adds the listener function to the end of the listeners array for the event.\n   * No checks are made to see if the listener has already been added. Multiple calls passing\n   * the same combination of event and listener will result in the listener being added, and\n   * called, multiple times.\n   * @returns this MessageStream, so that calls can be chained\n   */\n  on(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event] = []);\n    listeners.push({\n      listener\n    });\n    return this;\n  }\n  /**\n   * Removes the specified listener from the listener array for the event.\n   * off() will remove, at most, one instance of a listener from the listener array. If any single\n   * listener has been added multiple times to the listener array for the specified event, then\n   * off() must be called multiple times to remove each instance.\n   * @returns this MessageStream, so that calls can be chained\n   */\n  off(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event];\n    if (!listeners) return this;\n    const index = listeners.findIndex(l => l.listener === listener);\n    if (index >= 0) listeners.splice(index, 1);\n    return this;\n  }\n  /**\n   * Adds a one-time listener function for the event. The next time the event is triggered,\n   * this listener is removed and then invoked.\n   * @returns this MessageStream, so that calls can be chained\n   */\n  once(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event] = []);\n    listeners.push({\n      listener,\n      once: true\n    });\n    return this;\n  }\n  /**\n   * This is similar to `.once()`, but returns a Promise that resolves the next time\n   * the event is triggered, instead of calling a listener callback.\n   * @returns a Promise that resolves the next time given event is triggered,\n   * or rejects if an error is emitted.  (If you request the 'error' event,\n   * returns a promise that resolves with the error).\n   *\n   * Example:\n   *\n   *   const message = await stream.emitted('message') // rejects if the stream errors\n   */\n  emitted(event) {\n    return new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _MessageStream_catchingPromiseCreated, true, \"f\");\n      if (event !== 'error') this.once('error', reject);\n      this.once(event, resolve);\n    });\n  }\n  async done() {\n    __classPrivateFieldSet(this, _MessageStream_catchingPromiseCreated, true, \"f\");\n    await __classPrivateFieldGet(this, _MessageStream_endPromise, \"f\");\n  }\n  get currentMessage() {\n    return __classPrivateFieldGet(this, _MessageStream_currentMessageSnapshot, \"f\");\n  }\n  /**\n   * @returns a promise that resolves with the the final assistant Message response,\n   * or rejects if an error occurred or the stream ended prematurely without producing a Message.\n   */\n  async finalMessage() {\n    await this.done();\n    return __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_getFinalMessage).call(this);\n  }\n  /**\n   * @returns a promise that resolves with the the final assistant Message's text response, concatenated\n   * together if there are more than one text blocks.\n   * Rejects if an error occurred or the stream ended prematurely without producing a Message.\n   */\n  async finalText() {\n    await this.done();\n    return __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_getFinalText).call(this);\n  }\n  _emit(event, ...args) {\n    // make sure we don't emit any MessageStreamEvents after end\n    if (__classPrivateFieldGet(this, _MessageStream_ended, \"f\")) return;\n    if (event === 'end') {\n      __classPrivateFieldSet(this, _MessageStream_ended, true, \"f\");\n      __classPrivateFieldGet(this, _MessageStream_resolveEndPromise, \"f\").call(this);\n    }\n    const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event];\n    if (listeners) {\n      __classPrivateFieldGet(this, _MessageStream_listeners, \"f\")[event] = listeners.filter(l => !l.once);\n      listeners.forEach(({\n        listener\n      }) => listener(...args));\n    }\n    if (event === 'abort') {\n      const error = args[0];\n      if (!__classPrivateFieldGet(this, _MessageStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n        Promise.reject(error);\n      }\n      __classPrivateFieldGet(this, _MessageStream_rejectConnectedPromise, \"f\").call(this, error);\n      __classPrivateFieldGet(this, _MessageStream_rejectEndPromise, \"f\").call(this, error);\n      this._emit('end');\n      return;\n    }\n    if (event === 'error') {\n      // NOTE: _emit('error', error) should only be called from #handleError().\n      const error = args[0];\n      if (!__classPrivateFieldGet(this, _MessageStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n        // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n        // If you are seeing stack traces here, make sure to handle errors via either:\n        // - runner.on('error', () => ...)\n        // - await runner.done()\n        // - await runner.final...()\n        // - etc.\n        Promise.reject(error);\n      }\n      __classPrivateFieldGet(this, _MessageStream_rejectConnectedPromise, \"f\").call(this, error);\n      __classPrivateFieldGet(this, _MessageStream_rejectEndPromise, \"f\").call(this, error);\n      this._emit('end');\n    }\n  }\n  _emitFinal() {\n    const finalMessage = this.receivedMessages.at(-1);\n    if (finalMessage) {\n      this._emit('finalMessage', __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_getFinalMessage).call(this));\n    }\n  }\n  async _fromReadableStream(readableStream, options) {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_beginRequest).call(this);\n    this._connected();\n    const stream = Stream.fromReadableStream(readableStream, this.controller);\n    for await (const event of stream) {\n      __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_addStreamEvent).call(this, event);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_endRequest).call(this);\n  }\n  [(_MessageStream_currentMessageSnapshot = new WeakMap(), _MessageStream_connectedPromise = new WeakMap(), _MessageStream_resolveConnectedPromise = new WeakMap(), _MessageStream_rejectConnectedPromise = new WeakMap(), _MessageStream_endPromise = new WeakMap(), _MessageStream_resolveEndPromise = new WeakMap(), _MessageStream_rejectEndPromise = new WeakMap(), _MessageStream_listeners = new WeakMap(), _MessageStream_ended = new WeakMap(), _MessageStream_errored = new WeakMap(), _MessageStream_aborted = new WeakMap(), _MessageStream_catchingPromiseCreated = new WeakMap(), _MessageStream_handleError = new WeakMap(), _MessageStream_instances = new WeakSet(), _MessageStream_getFinalMessage = function _MessageStream_getFinalMessage() {\n    if (this.receivedMessages.length === 0) {\n      throw new AnthropicError('stream ended without producing a Message with role=assistant');\n    }\n    return this.receivedMessages.at(-1);\n  }, _MessageStream_getFinalText = function _MessageStream_getFinalText() {\n    if (this.receivedMessages.length === 0) {\n      throw new AnthropicError('stream ended without producing a Message with role=assistant');\n    }\n    const textBlocks = this.receivedMessages.at(-1).content.filter(block => block.type === 'text').map(block => block.text);\n    if (textBlocks.length === 0) {\n      throw new AnthropicError('stream ended without producing a content block with type=text');\n    }\n    return textBlocks.join(' ');\n  }, _MessageStream_beginRequest = function _MessageStream_beginRequest() {\n    if (this.ended) return;\n    __classPrivateFieldSet(this, _MessageStream_currentMessageSnapshot, undefined, \"f\");\n  }, _MessageStream_addStreamEvent = function _MessageStream_addStreamEvent(event) {\n    if (this.ended) return;\n    const messageSnapshot = __classPrivateFieldGet(this, _MessageStream_instances, \"m\", _MessageStream_accumulateMessage).call(this, event);\n    this._emit('streamEvent', event, messageSnapshot);\n    switch (event.type) {\n      case 'content_block_delta':\n        {\n          const content = messageSnapshot.content.at(-1);\n          if (event.delta.type === 'text_delta' && content.type === 'text') {\n            this._emit('text', event.delta.text, content.text || '');\n          } else if (event.delta.type === 'input_json_delta' && content.type === 'tool_use') {\n            if (content.input) {\n              this._emit('inputJson', event.delta.partial_json, content.input);\n            }\n          }\n          break;\n        }\n      case 'message_stop':\n        {\n          this._addMessageParam(messageSnapshot);\n          this._addMessage(messageSnapshot, true);\n          break;\n        }\n      case 'content_block_stop':\n        {\n          this._emit('contentBlock', messageSnapshot.content.at(-1));\n          break;\n        }\n      case 'message_start':\n        {\n          __classPrivateFieldSet(this, _MessageStream_currentMessageSnapshot, messageSnapshot, \"f\");\n          break;\n        }\n      case 'content_block_start':\n      case 'message_delta':\n        break;\n    }\n  }, _MessageStream_endRequest = function _MessageStream_endRequest() {\n    if (this.ended) {\n      throw new AnthropicError(`stream has ended, this shouldn't happen`);\n    }\n    const snapshot = __classPrivateFieldGet(this, _MessageStream_currentMessageSnapshot, \"f\");\n    if (!snapshot) {\n      throw new AnthropicError(`request ended without sending any chunks`);\n    }\n    __classPrivateFieldSet(this, _MessageStream_currentMessageSnapshot, undefined, \"f\");\n    return snapshot;\n  }, _MessageStream_accumulateMessage = function _MessageStream_accumulateMessage(event) {\n    let snapshot = __classPrivateFieldGet(this, _MessageStream_currentMessageSnapshot, \"f\");\n    if (event.type === 'message_start') {\n      if (snapshot) {\n        throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving \"message_stop\"`);\n      }\n      return event.message;\n    }\n    if (!snapshot) {\n      throw new AnthropicError(`Unexpected event order, got ${event.type} before \"message_start\"`);\n    }\n    switch (event.type) {\n      case 'message_stop':\n        return snapshot;\n      case 'message_delta':\n        snapshot.stop_reason = event.delta.stop_reason;\n        snapshot.stop_sequence = event.delta.stop_sequence;\n        snapshot.usage.output_tokens = event.usage.output_tokens;\n        return snapshot;\n      case 'content_block_start':\n        snapshot.content.push(event.content_block);\n        return snapshot;\n      case 'content_block_delta':\n        {\n          const snapshotContent = snapshot.content.at(event.index);\n          if (snapshotContent?.type === 'text' && event.delta.type === 'text_delta') {\n            snapshotContent.text += event.delta.text;\n          } else if (snapshotContent?.type === 'tool_use' && event.delta.type === 'input_json_delta') {\n            // we need to keep track of the raw JSON string as well so that we can\n            // re-parse it for each delta, for now we just store it as an untyped\n            // non-enumerable property on the snapshot\n            let jsonBuf = snapshotContent[JSON_BUF_PROPERTY] || '';\n            jsonBuf += event.delta.partial_json;\n            Object.defineProperty(snapshotContent, JSON_BUF_PROPERTY, {\n              value: jsonBuf,\n              enumerable: false,\n              writable: true\n            });\n            if (jsonBuf) {\n              snapshotContent.input = partialParse(jsonBuf);\n            }\n          }\n          return snapshot;\n        }\n      case 'content_block_stop':\n        return snapshot;\n    }\n  }, Symbol.asyncIterator)]() {\n    const pushQueue = [];\n    const readQueue = [];\n    let done = false;\n    this.on('streamEvent', event => {\n      const reader = readQueue.shift();\n      if (reader) {\n        reader.resolve(event);\n      } else {\n        pushQueue.push(event);\n      }\n    });\n    this.on('end', () => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.resolve(undefined);\n      }\n      readQueue.length = 0;\n    });\n    this.on('abort', err => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n    this.on('error', err => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n    return {\n      next: async () => {\n        if (!pushQueue.length) {\n          if (done) {\n            return {\n              value: undefined,\n              done: true\n            };\n          }\n          return new Promise((resolve, reject) => readQueue.push({\n            resolve,\n            reject\n          })).then(chunk => chunk ? {\n            value: chunk,\n            done: false\n          } : {\n            value: undefined,\n            done: true\n          });\n        }\n        const chunk = pushQueue.shift();\n        return {\n          value: chunk,\n          done: false\n        };\n      },\n      return: async () => {\n        this.abort();\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n    };\n  }\n  toReadableStream() {\n    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n    return stream.toReadableStream();\n  }\n}","map":{"version":3,"names":["AnthropicError","APIUserAbortError","Stream","partialParse","JSON_BUF_PROPERTY","MessageStream","constructor","messages","receivedMessages","_MessageStream_currentMessageSnapshot","set","controller","AbortController","_MessageStream_connectedPromise","_MessageStream_resolveConnectedPromise","_MessageStream_rejectConnectedPromise","_MessageStream_endPromise","_MessageStream_resolveEndPromise","_MessageStream_rejectEndPromise","_MessageStream_listeners","_MessageStream_ended","_MessageStream_errored","_MessageStream_aborted","_MessageStream_catchingPromiseCreated","_MessageStream_handleError","error","__classPrivateFieldSet","Error","name","_emit","anthropicError","message","cause","String","Promise","resolve","reject","__classPrivateFieldGet","catch","fromReadableStream","stream","runner","_run","_fromReadableStream","createMessage","params","options","_addMessageParam","_createMessage","headers","executor","then","_emitFinal","push","_addMessage","emit","signal","aborted","abort","addEventListener","_MessageStream_instances","_MessageStream_beginRequest","call","create","_connected","event","_MessageStream_addStreamEvent","_MessageStream_endRequest","ended","errored","on","listener","listeners","off","index","findIndex","l","splice","once","emitted","done","currentMessage","finalMessage","_MessageStream_getFinalMessage","finalText","_MessageStream_getFinalText","args","filter","forEach","length","at","readableStream","WeakMap","WeakSet","textBlocks","content","block","type","map","text","join","undefined","messageSnapshot","_MessageStream_accumulateMessage","delta","input","partial_json","snapshot","stop_reason","stop_sequence","usage","output_tokens","content_block","snapshotContent","jsonBuf","Object","defineProperty","value","enumerable","writable","Symbol","asyncIterator","pushQueue","readQueue","reader","shift","err","next","chunk","return","toReadableStream","bind"],"sources":["/home/user/srt-translator/node_modules/@anthropic-ai/sdk/src/lib/MessageStream.ts"],"sourcesContent":["import * as Core from \"../core.js\";\nimport { AnthropicError, APIUserAbortError } from \"../error.js\";\nimport {\n  type ContentBlock,\n  Messages,\n  type Message,\n  type MessageStreamEvent,\n  type MessageParam,\n  type MessageCreateParams,\n  type MessageCreateParamsBase,\n  type TextBlock,\n} from \"../resources/messages.js\";\nimport { type ReadableStream } from \"../_shims/index.js\";\nimport { Stream } from \"../streaming.js\";\nimport { partialParse } from \"../_vendor/partial-json-parser/parser.js\";\n\nexport interface MessageStreamEvents {\n  connect: () => void;\n  streamEvent: (event: MessageStreamEvent, snapshot: Message) => void;\n  text: (textDelta: string, textSnapshot: string) => void;\n  inputJson: (partialJson: string, jsonSnapshot: unknown) => void;\n  message: (message: Message) => void;\n  contentBlock: (content: ContentBlock) => void;\n  finalMessage: (message: Message) => void;\n  error: (error: AnthropicError) => void;\n  abort: (error: APIUserAbortError) => void;\n  end: () => void;\n}\n\ntype MessageStreamEventListeners<Event extends keyof MessageStreamEvents> = {\n  listener: MessageStreamEvents[Event];\n  once?: boolean;\n}[];\n\nconst JSON_BUF_PROPERTY = '__json_buf';\n\nexport class MessageStream implements AsyncIterable<MessageStreamEvent> {\n  messages: MessageParam[] = [];\n  receivedMessages: Message[] = [];\n  #currentMessageSnapshot: Message | undefined;\n\n  controller: AbortController = new AbortController();\n\n  #connectedPromise: Promise<void>;\n  #resolveConnectedPromise: () => void = () => {};\n  #rejectConnectedPromise: (error: AnthropicError) => void = () => {};\n\n  #endPromise: Promise<void>;\n  #resolveEndPromise: () => void = () => {};\n  #rejectEndPromise: (error: AnthropicError) => void = () => {};\n\n  #listeners: { [Event in keyof MessageStreamEvents]?: MessageStreamEventListeners<Event> } = {};\n\n  #ended = false;\n  #errored = false;\n  #aborted = false;\n  #catchingPromiseCreated = false;\n\n  constructor() {\n    this.#connectedPromise = new Promise<void>((resolve, reject) => {\n      this.#resolveConnectedPromise = resolve;\n      this.#rejectConnectedPromise = reject;\n    });\n\n    this.#endPromise = new Promise<void>((resolve, reject) => {\n      this.#resolveEndPromise = resolve;\n      this.#rejectEndPromise = reject;\n    });\n\n    // Don't let these promises cause unhandled rejection errors.\n    // we will manually cause an unhandled rejection error later\n    // if the user hasn't registered any error listener or called\n    // any promise-returning method.\n    this.#connectedPromise.catch(() => {});\n    this.#endPromise.catch(() => {});\n  }\n\n  /**\n   * Intended for use on the frontend, consuming a stream produced with\n   * `.toReadableStream()` on the backend.\n   *\n   * Note that messages sent to the model do not appear in `.on('message')`\n   * in this context.\n   */\n  static fromReadableStream(stream: ReadableStream): MessageStream {\n    const runner = new MessageStream();\n    runner._run(() => runner._fromReadableStream(stream));\n    return runner;\n  }\n\n  static createMessage(\n    messages: Messages,\n    params: MessageCreateParamsBase,\n    options?: Core.RequestOptions,\n  ): MessageStream {\n    const runner = new MessageStream();\n    for (const message of params.messages) {\n      runner._addMessageParam(message);\n    }\n    runner._run(() =>\n      runner._createMessage(\n        messages,\n        { ...params, stream: true },\n        { ...options, headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' } },\n      ),\n    );\n    return runner;\n  }\n\n  protected _run(executor: () => Promise<any>) {\n    executor().then(() => {\n      this._emitFinal();\n      this._emit('end');\n    }, this.#handleError);\n  }\n\n  protected _addMessageParam(message: MessageParam) {\n    this.messages.push(message);\n  }\n\n  protected _addMessage(message: Message, emit = true) {\n    this.receivedMessages.push(message);\n    if (emit) {\n      this._emit('message', message);\n    }\n  }\n\n  protected async _createMessage(\n    messages: Messages,\n    params: MessageCreateParams,\n    options?: Core.RequestOptions,\n  ): Promise<void> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    this.#beginRequest();\n    const stream = await messages.create(\n      { ...params, stream: true },\n      { ...options, signal: this.controller.signal },\n    );\n    this._connected();\n    for await (const event of stream) {\n      this.#addStreamEvent(event);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    this.#endRequest();\n  }\n\n  protected _connected() {\n    if (this.ended) return;\n    this.#resolveConnectedPromise();\n    this._emit('connect');\n  }\n\n  get ended(): boolean {\n    return this.#ended;\n  }\n\n  get errored(): boolean {\n    return this.#errored;\n  }\n\n  get aborted(): boolean {\n    return this.#aborted;\n  }\n\n  abort() {\n    this.controller.abort();\n  }\n\n  /**\n   * Adds the listener function to the end of the listeners array for the event.\n   * No checks are made to see if the listener has already been added. Multiple calls passing\n   * the same combination of event and listener will result in the listener being added, and\n   * called, multiple times.\n   * @returns this MessageStream, so that calls can be chained\n   */\n  on<Event extends keyof MessageStreamEvents>(event: Event, listener: MessageStreamEvents[Event]): this {\n    const listeners: MessageStreamEventListeners<Event> =\n      this.#listeners[event] || (this.#listeners[event] = []);\n    listeners.push({ listener });\n    return this;\n  }\n\n  /**\n   * Removes the specified listener from the listener array for the event.\n   * off() will remove, at most, one instance of a listener from the listener array. If any single\n   * listener has been added multiple times to the listener array for the specified event, then\n   * off() must be called multiple times to remove each instance.\n   * @returns this MessageStream, so that calls can be chained\n   */\n  off<Event extends keyof MessageStreamEvents>(event: Event, listener: MessageStreamEvents[Event]): this {\n    const listeners = this.#listeners[event];\n    if (!listeners) return this;\n    const index = listeners.findIndex((l) => l.listener === listener);\n    if (index >= 0) listeners.splice(index, 1);\n    return this;\n  }\n\n  /**\n   * Adds a one-time listener function for the event. The next time the event is triggered,\n   * this listener is removed and then invoked.\n   * @returns this MessageStream, so that calls can be chained\n   */\n  once<Event extends keyof MessageStreamEvents>(event: Event, listener: MessageStreamEvents[Event]): this {\n    const listeners: MessageStreamEventListeners<Event> =\n      this.#listeners[event] || (this.#listeners[event] = []);\n    listeners.push({ listener, once: true });\n    return this;\n  }\n\n  /**\n   * This is similar to `.once()`, but returns a Promise that resolves the next time\n   * the event is triggered, instead of calling a listener callback.\n   * @returns a Promise that resolves the next time given event is triggered,\n   * or rejects if an error is emitted.  (If you request the 'error' event,\n   * returns a promise that resolves with the error).\n   *\n   * Example:\n   *\n   *   const message = await stream.emitted('message') // rejects if the stream errors\n   */\n  emitted<Event extends keyof MessageStreamEvents>(\n    event: Event,\n  ): Promise<\n    Parameters<MessageStreamEvents[Event]> extends [infer Param] ? Param\n    : Parameters<MessageStreamEvents[Event]> extends [] ? void\n    : Parameters<MessageStreamEvents[Event]>\n  > {\n    return new Promise((resolve, reject) => {\n      this.#catchingPromiseCreated = true;\n      if (event !== 'error') this.once('error', reject);\n      this.once(event, resolve as any);\n    });\n  }\n\n  async done(): Promise<void> {\n    this.#catchingPromiseCreated = true;\n    await this.#endPromise;\n  }\n\n  get currentMessage(): Message | undefined {\n    return this.#currentMessageSnapshot;\n  }\n\n  #getFinalMessage(): Message {\n    if (this.receivedMessages.length === 0) {\n      throw new AnthropicError('stream ended without producing a Message with role=assistant');\n    }\n    return this.receivedMessages.at(-1)!;\n  }\n\n  /**\n   * @returns a promise that resolves with the the final assistant Message response,\n   * or rejects if an error occurred or the stream ended prematurely without producing a Message.\n   */\n  async finalMessage(): Promise<Message> {\n    await this.done();\n    return this.#getFinalMessage();\n  }\n\n  #getFinalText(): string {\n    if (this.receivedMessages.length === 0) {\n      throw new AnthropicError('stream ended without producing a Message with role=assistant');\n    }\n    const textBlocks = this.receivedMessages\n      .at(-1)!\n      .content.filter((block): block is TextBlock => block.type === 'text')\n      .map((block) => block.text);\n    if (textBlocks.length === 0) {\n      throw new AnthropicError('stream ended without producing a content block with type=text');\n    }\n    return textBlocks.join(' ');\n  }\n\n  /**\n   * @returns a promise that resolves with the the final assistant Message's text response, concatenated\n   * together if there are more than one text blocks.\n   * Rejects if an error occurred or the stream ended prematurely without producing a Message.\n   */\n  async finalText(): Promise<string> {\n    await this.done();\n    return this.#getFinalText();\n  }\n\n  #handleError = (error: unknown) => {\n    this.#errored = true;\n    if (error instanceof Error && error.name === 'AbortError') {\n      error = new APIUserAbortError();\n    }\n    if (error instanceof APIUserAbortError) {\n      this.#aborted = true;\n      return this._emit('abort', error);\n    }\n    if (error instanceof AnthropicError) {\n      return this._emit('error', error);\n    }\n    if (error instanceof Error) {\n      const anthropicError: AnthropicError = new AnthropicError(error.message);\n      // @ts-ignore\n      anthropicError.cause = error;\n      return this._emit('error', anthropicError);\n    }\n    return this._emit('error', new AnthropicError(String(error)));\n  };\n\n  protected _emit<Event extends keyof MessageStreamEvents>(\n    event: Event,\n    ...args: Parameters<MessageStreamEvents[Event]>\n  ) {\n    // make sure we don't emit any MessageStreamEvents after end\n    if (this.#ended) return;\n\n    if (event === 'end') {\n      this.#ended = true;\n      this.#resolveEndPromise();\n    }\n\n    const listeners: MessageStreamEventListeners<Event> | undefined = this.#listeners[event];\n    if (listeners) {\n      this.#listeners[event] = listeners.filter((l) => !l.once) as any;\n      listeners.forEach(({ listener }: any) => listener(...args));\n    }\n\n    if (event === 'abort') {\n      const error = args[0] as APIUserAbortError;\n      if (!this.#catchingPromiseCreated && !listeners?.length) {\n        Promise.reject(error);\n      }\n      this.#rejectConnectedPromise(error);\n      this.#rejectEndPromise(error);\n      this._emit('end');\n      return;\n    }\n\n    if (event === 'error') {\n      // NOTE: _emit('error', error) should only be called from #handleError().\n\n      const error = args[0] as AnthropicError;\n      if (!this.#catchingPromiseCreated && !listeners?.length) {\n        // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n        // If you are seeing stack traces here, make sure to handle errors via either:\n        // - runner.on('error', () => ...)\n        // - await runner.done()\n        // - await runner.final...()\n        // - etc.\n        Promise.reject(error);\n      }\n      this.#rejectConnectedPromise(error);\n      this.#rejectEndPromise(error);\n      this._emit('end');\n    }\n  }\n\n  protected _emitFinal() {\n    const finalMessage = this.receivedMessages.at(-1);\n    if (finalMessage) {\n      this._emit('finalMessage', this.#getFinalMessage());\n    }\n  }\n\n  #beginRequest() {\n    if (this.ended) return;\n    this.#currentMessageSnapshot = undefined;\n  }\n  #addStreamEvent(event: MessageStreamEvent) {\n    if (this.ended) return;\n    const messageSnapshot = this.#accumulateMessage(event);\n    this._emit('streamEvent', event, messageSnapshot);\n\n    switch (event.type) {\n      case 'content_block_delta': {\n        const content = messageSnapshot.content.at(-1)!;\n        if (event.delta.type === 'text_delta' && content.type === 'text') {\n          this._emit('text', event.delta.text, content.text || '');\n        } else if (event.delta.type === 'input_json_delta' && content.type === 'tool_use') {\n          if (content.input) {\n            this._emit('inputJson', event.delta.partial_json, content.input);\n          }\n        }\n        break;\n      }\n      case 'message_stop': {\n        this._addMessageParam(messageSnapshot);\n        this._addMessage(messageSnapshot, true);\n        break;\n      }\n      case 'content_block_stop': {\n        this._emit('contentBlock', messageSnapshot.content.at(-1)!);\n        break;\n      }\n      case 'message_start': {\n        this.#currentMessageSnapshot = messageSnapshot;\n        break;\n      }\n      case 'content_block_start':\n      case 'message_delta':\n        break;\n    }\n  }\n  #endRequest(): Message {\n    if (this.ended) {\n      throw new AnthropicError(`stream has ended, this shouldn't happen`);\n    }\n    const snapshot = this.#currentMessageSnapshot;\n    if (!snapshot) {\n      throw new AnthropicError(`request ended without sending any chunks`);\n    }\n    this.#currentMessageSnapshot = undefined;\n    return snapshot;\n  }\n\n  protected async _fromReadableStream(\n    readableStream: ReadableStream,\n    options?: Core.RequestOptions,\n  ): Promise<void> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    this.#beginRequest();\n    this._connected();\n    const stream = Stream.fromReadableStream<MessageStreamEvent>(readableStream, this.controller);\n    for await (const event of stream) {\n      this.#addStreamEvent(event);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    this.#endRequest();\n  }\n\n  /**\n   * Mutates this.#currentMessage with the current event. Handling the accumulation of multiple messages\n   * will be needed to be handled by the caller, this method will throw if you try to accumulate for multiple\n   * messages.\n   */\n  #accumulateMessage(event: MessageStreamEvent): Message {\n    let snapshot = this.#currentMessageSnapshot;\n\n    if (event.type === 'message_start') {\n      if (snapshot) {\n        throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving \"message_stop\"`);\n      }\n      return event.message;\n    }\n\n    if (!snapshot) {\n      throw new AnthropicError(`Unexpected event order, got ${event.type} before \"message_start\"`);\n    }\n\n    switch (event.type) {\n      case 'message_stop':\n        return snapshot;\n      case 'message_delta':\n        snapshot.stop_reason = event.delta.stop_reason;\n        snapshot.stop_sequence = event.delta.stop_sequence;\n        snapshot.usage.output_tokens = event.usage.output_tokens;\n        return snapshot;\n      case 'content_block_start':\n        snapshot.content.push(event.content_block);\n        return snapshot;\n      case 'content_block_delta': {\n        const snapshotContent = snapshot.content.at(event.index);\n        if (snapshotContent?.type === 'text' && event.delta.type === 'text_delta') {\n          snapshotContent.text += event.delta.text;\n        } else if (snapshotContent?.type === 'tool_use' && event.delta.type === 'input_json_delta') {\n          // we need to keep track of the raw JSON string as well so that we can\n          // re-parse it for each delta, for now we just store it as an untyped\n          // non-enumerable property on the snapshot\n          let jsonBuf = (snapshotContent as any)[JSON_BUF_PROPERTY] || '';\n          jsonBuf += event.delta.partial_json;\n\n          Object.defineProperty(snapshotContent, JSON_BUF_PROPERTY, {\n            value: jsonBuf,\n            enumerable: false,\n            writable: true,\n          });\n\n          if (jsonBuf) {\n            snapshotContent.input = partialParse(jsonBuf);\n          }\n        }\n        return snapshot;\n      }\n      case 'content_block_stop':\n        return snapshot;\n    }\n  }\n\n  [Symbol.asyncIterator](): AsyncIterator<MessageStreamEvent> {\n    const pushQueue: MessageStreamEvent[] = [];\n    const readQueue: {\n      resolve: (chunk: MessageStreamEvent | undefined) => void;\n      reject: (error: unknown) => void;\n    }[] = [];\n    let done = false;\n\n    this.on('streamEvent', (event) => {\n      const reader = readQueue.shift();\n      if (reader) {\n        reader.resolve(event);\n      } else {\n        pushQueue.push(event);\n      }\n    });\n\n    this.on('end', () => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.resolve(undefined);\n      }\n      readQueue.length = 0;\n    });\n\n    this.on('abort', (err) => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n\n    this.on('error', (err) => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n\n    return {\n      next: async (): Promise<IteratorResult<MessageStreamEvent>> => {\n        if (!pushQueue.length) {\n          if (done) {\n            return { value: undefined, done: true };\n          }\n          return new Promise<MessageStreamEvent | undefined>((resolve, reject) =>\n            readQueue.push({ resolve, reject }),\n          ).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\n        }\n        const chunk = pushQueue.shift()!;\n        return { value: chunk, done: false };\n      },\n      return: async () => {\n        this.abort();\n        return { value: undefined, done: true };\n      },\n    };\n  }\n\n  toReadableStream(): ReadableStream {\n    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n    return stream.toReadableStream();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
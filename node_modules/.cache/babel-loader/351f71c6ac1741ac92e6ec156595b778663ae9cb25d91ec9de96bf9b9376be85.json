{"ast":null,"code":"// translateSrt.ts\n\nexport const translateSrt = async (fileContent, apiKey, language, onStatus) => {\n  const maxRetries = 5;\n  const initialDelay = 10000; // 10 seconds\n  const maxDelay = 120000; // 2 minutes\n\n  const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\n  let lastDelay = initialDelay;\n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      var _data$choices, _data$choices$, _data$choices$$messag;\n      onStatus({\n        message: `Attempt ${attempt}/${maxRetries}: Sending translation request...`\n      });\n      const response = await fetch(\"https://api.openai.com/v1/chat/completions\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${apiKey}`\n        },\n        body: JSON.stringify({\n          model: \"gpt-4\",\n          messages: [{\n            role: \"system\",\n            content: `You are a professional subtitle translator. Translate the following SRT content to ${language}. Maintain the exact same timing and formatting.`\n          }, {\n            role: \"user\",\n            content: fileContent\n          }],\n          temperature: 0.7,\n          max_tokens: 4000\n        })\n      });\n      if (response.status === 429) {\n        const retryAfter = parseInt(response.headers.get(\"Retry-After\") || \"0\", 10);\n        const delay = retryAfter > 0 ? retryAfter * 1000 : Math.min(lastDelay * 2, maxDelay);\n        lastDelay = delay;\n        onStatus({\n          message: `Rate limit reached. Waiting ${delay / 1000} seconds before retry...`,\n          attempt,\n          delay\n        });\n        await sleep(delay);\n        continue;\n      }\n      if (!response.ok) {\n        var _errorData$error;\n        const errorData = await response.json();\n        throw new Error(((_errorData$error = errorData.error) === null || _errorData$error === void 0 ? void 0 : _errorData$error.message) || `API error: ${response.status}`);\n      }\n      const data = await response.json();\n      const translatedText = data === null || data === void 0 ? void 0 : (_data$choices = data.choices) === null || _data$choices === void 0 ? void 0 : (_data$choices$ = _data$choices[0]) === null || _data$choices$ === void 0 ? void 0 : (_data$choices$$messag = _data$choices$.message) === null || _data$choices$$messag === void 0 ? void 0 : _data$choices$$messag.content;\n      if (!translatedText) {\n        throw new Error(\"Received empty translation result\");\n      }\n      onStatus({\n        message: \"Translation completed successfully!\"\n      });\n      return translatedText;\n    } catch (error) {\n      if (attempt === maxRetries) {\n        throw new Error(`Translation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n      }\n      const delay = Math.min(lastDelay * 2, maxDelay);\n      lastDelay = delay;\n      onStatus({\n        message: `Error occurred. Retrying in ${delay / 1000} seconds...`,\n        attempt,\n        delay\n      });\n      await sleep(delay);\n    }\n  }\n  throw new Error(\"Translation failed after all retry attempts\");\n};","map":{"version":3,"names":["translateSrt","fileContent","apiKey","language","onStatus","maxRetries","initialDelay","maxDelay","sleep","ms","Promise","resolve","setTimeout","lastDelay","attempt","_data$choices","_data$choices$","_data$choices$$messag","message","response","fetch","method","headers","Authorization","body","JSON","stringify","model","messages","role","content","temperature","max_tokens","status","retryAfter","parseInt","get","delay","Math","min","ok","_errorData$error","errorData","json","Error","error","data","translatedText","choices"],"sources":["/home/user/srt-translator/src/utils/translateSrt.ts"],"sourcesContent":["// translateSrt.ts\nexport interface TranslationStatus {\n  message: string;\n  attempt?: number;\n  delay?: number;\n}\n\nexport const translateSrt = async (\n  fileContent: string,\n  apiKey: string,\n  language: string,\n  onStatus: (status: TranslationStatus) => void\n): Promise<string> => {\n  const maxRetries = 5;\n  const initialDelay = 10000; // 10 seconds\n  const maxDelay = 120000;    // 2 minutes\n\n  const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\n  let lastDelay = initialDelay;\n\n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      onStatus({\n        message: `Attempt ${attempt}/${maxRetries}: Sending translation request...`\n      });\n\n      const response = await fetch(\"https://api.openai.com/v1/chat/completions\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${apiKey}`,\n        },\n        body: JSON.stringify({\n          model: \"gpt-4\",\n          messages: [\n            {\n              role: \"system\",\n              content: `You are a professional subtitle translator. Translate the following SRT content to ${language}. Maintain the exact same timing and formatting.`,\n            },\n            { role: \"user\", content: fileContent },\n          ],\n          temperature: 0.7,\n          max_tokens: 4000,\n        }),\n      });\n\n      if (response.status === 429) {\n        const retryAfter = parseInt(response.headers.get(\"Retry-After\") || \"0\", 10);\n        const delay = retryAfter > 0 ? retryAfter * 1000 : Math.min(lastDelay * 2, maxDelay);\n        lastDelay = delay;\n\n        onStatus({\n          message: `Rate limit reached. Waiting ${delay / 1000} seconds before retry...`,\n          attempt,\n          delay\n        });\n\n        await sleep(delay);\n        continue;\n      }\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.error?.message || `API error: ${response.status}`);\n      }\n\n      const data = await response.json();\n      const translatedText = data?.choices?.[0]?.message?.content;\n\n      if (!translatedText) {\n        throw new Error(\"Received empty translation result\");\n      }\n\n      onStatus({\n        message: \"Translation completed successfully!\"\n      });\n\n      return translatedText;\n\n    } catch (error) {\n      if (attempt === maxRetries) {\n        throw new Error(`Translation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n      }\n\n      const delay = Math.min(lastDelay * 2, maxDelay);\n      lastDelay = delay;\n\n      onStatus({\n        message: `Error occurred. Retrying in ${delay / 1000} seconds...`,\n        attempt,\n        delay\n      });\n\n      await sleep(delay);\n    }\n  }\n\n  throw new Error(\"Translation failed after all retry attempts\");\n};"],"mappings":"AAAA;;AAOA,OAAO,MAAMA,YAAY,GAAG,MAAAA,CAC1BC,WAAmB,EACnBC,MAAc,EACdC,QAAgB,EAChBC,QAA6C,KACzB;EACpB,MAAMC,UAAU,GAAG,CAAC;EACpB,MAAMC,YAAY,GAAG,KAAK,CAAC,CAAC;EAC5B,MAAMC,QAAQ,GAAG,MAAM,CAAC,CAAI;;EAE5B,MAAMC,KAAK,GAAIC,EAAU,IAAK,IAAIC,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAEF,EAAE,CAAC,CAAC;EAE7E,IAAII,SAAS,GAAGP,YAAY;EAE5B,KAAK,IAAIQ,OAAO,GAAG,CAAC,EAAEA,OAAO,IAAIT,UAAU,EAAES,OAAO,EAAE,EAAE;IACtD,IAAI;MAAA,IAAAC,aAAA,EAAAC,cAAA,EAAAC,qBAAA;MACFb,QAAQ,CAAC;QACPc,OAAO,EAAE,WAAWJ,OAAO,IAAIT,UAAU;MAC3C,CAAC,CAAC;MAEF,MAAMc,QAAQ,GAAG,MAAMC,KAAK,CAAC,4CAA4C,EAAE;QACzEC,MAAM,EAAE,MAAM;QACdC,OAAO,EAAE;UACP,cAAc,EAAE,kBAAkB;UAClCC,aAAa,EAAE,UAAUrB,MAAM;QACjC,CAAC;QACDsB,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;UACnBC,KAAK,EAAE,OAAO;UACdC,QAAQ,EAAE,CACR;YACEC,IAAI,EAAE,QAAQ;YACdC,OAAO,EAAE,sFAAsF3B,QAAQ;UACzG,CAAC,EACD;YAAE0B,IAAI,EAAE,MAAM;YAAEC,OAAO,EAAE7B;UAAY,CAAC,CACvC;UACD8B,WAAW,EAAE,GAAG;UAChBC,UAAU,EAAE;QACd,CAAC;MACH,CAAC,CAAC;MAEF,IAAIb,QAAQ,CAACc,MAAM,KAAK,GAAG,EAAE;QAC3B,MAAMC,UAAU,GAAGC,QAAQ,CAAChB,QAAQ,CAACG,OAAO,CAACc,GAAG,CAAC,aAAa,CAAC,IAAI,GAAG,EAAE,EAAE,CAAC;QAC3E,MAAMC,KAAK,GAAGH,UAAU,GAAG,CAAC,GAAGA,UAAU,GAAG,IAAI,GAAGI,IAAI,CAACC,GAAG,CAAC1B,SAAS,GAAG,CAAC,EAAEN,QAAQ,CAAC;QACpFM,SAAS,GAAGwB,KAAK;QAEjBjC,QAAQ,CAAC;UACPc,OAAO,EAAE,+BAA+BmB,KAAK,GAAG,IAAI,0BAA0B;UAC9EvB,OAAO;UACPuB;QACF,CAAC,CAAC;QAEF,MAAM7B,KAAK,CAAC6B,KAAK,CAAC;QAClB;MACF;MAEA,IAAI,CAAClB,QAAQ,CAACqB,EAAE,EAAE;QAAA,IAAAC,gBAAA;QAChB,MAAMC,SAAS,GAAG,MAAMvB,QAAQ,CAACwB,IAAI,CAAC,CAAC;QACvC,MAAM,IAAIC,KAAK,CAAC,EAAAH,gBAAA,GAAAC,SAAS,CAACG,KAAK,cAAAJ,gBAAA,uBAAfA,gBAAA,CAAiBvB,OAAO,KAAI,cAAcC,QAAQ,CAACc,MAAM,EAAE,CAAC;MAC9E;MAEA,MAAMa,IAAI,GAAG,MAAM3B,QAAQ,CAACwB,IAAI,CAAC,CAAC;MAClC,MAAMI,cAAc,GAAGD,IAAI,aAAJA,IAAI,wBAAA/B,aAAA,GAAJ+B,IAAI,CAAEE,OAAO,cAAAjC,aAAA,wBAAAC,cAAA,GAAbD,aAAA,CAAgB,CAAC,CAAC,cAAAC,cAAA,wBAAAC,qBAAA,GAAlBD,cAAA,CAAoBE,OAAO,cAAAD,qBAAA,uBAA3BA,qBAAA,CAA6Ba,OAAO;MAE3D,IAAI,CAACiB,cAAc,EAAE;QACnB,MAAM,IAAIH,KAAK,CAAC,mCAAmC,CAAC;MACtD;MAEAxC,QAAQ,CAAC;QACPc,OAAO,EAAE;MACX,CAAC,CAAC;MAEF,OAAO6B,cAAc;IAEvB,CAAC,CAAC,OAAOF,KAAK,EAAE;MACd,IAAI/B,OAAO,KAAKT,UAAU,EAAE;QAC1B,MAAM,IAAIuC,KAAK,CAAC,uBAAuBC,KAAK,YAAYD,KAAK,GAAGC,KAAK,CAAC3B,OAAO,GAAG,eAAe,EAAE,CAAC;MACpG;MAEA,MAAMmB,KAAK,GAAGC,IAAI,CAACC,GAAG,CAAC1B,SAAS,GAAG,CAAC,EAAEN,QAAQ,CAAC;MAC/CM,SAAS,GAAGwB,KAAK;MAEjBjC,QAAQ,CAAC;QACPc,OAAO,EAAE,+BAA+BmB,KAAK,GAAG,IAAI,aAAa;QACjEvB,OAAO;QACPuB;MACF,CAAC,CAAC;MAEF,MAAM7B,KAAK,CAAC6B,KAAK,CAAC;IACpB;EACF;EAEA,MAAM,IAAIO,KAAK,CAAC,6CAA6C,CAAC;AAChE,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _PromptCachingBetaMessageStream_instances, _PromptCachingBetaMessageStream_currentMessageSnapshot, _PromptCachingBetaMessageStream_connectedPromise, _PromptCachingBetaMessageStream_resolveConnectedPromise, _PromptCachingBetaMessageStream_rejectConnectedPromise, _PromptCachingBetaMessageStream_endPromise, _PromptCachingBetaMessageStream_resolveEndPromise, _PromptCachingBetaMessageStream_rejectEndPromise, _PromptCachingBetaMessageStream_listeners, _PromptCachingBetaMessageStream_ended, _PromptCachingBetaMessageStream_errored, _PromptCachingBetaMessageStream_aborted, _PromptCachingBetaMessageStream_catchingPromiseCreated, _PromptCachingBetaMessageStream_getFinalMessage, _PromptCachingBetaMessageStream_getFinalText, _PromptCachingBetaMessageStream_handleError, _PromptCachingBetaMessageStream_beginRequest, _PromptCachingBetaMessageStream_addStreamEvent, _PromptCachingBetaMessageStream_endRequest, _PromptCachingBetaMessageStream_accumulateMessage;\nimport { AnthropicError, APIUserAbortError } from '@anthropic-ai/sdk/error';\nimport { Stream } from '@anthropic-ai/sdk/streaming';\nimport { partialParse } from \"../_vendor/partial-json-parser/parser.mjs\";\nconst JSON_BUF_PROPERTY = '__json_buf';\nexport class PromptCachingBetaMessageStream {\n  constructor() {\n    _PromptCachingBetaMessageStream_instances.add(this);\n    this.messages = [];\n    this.receivedMessages = [];\n    _PromptCachingBetaMessageStream_currentMessageSnapshot.set(this, void 0);\n    this.controller = new AbortController();\n    _PromptCachingBetaMessageStream_connectedPromise.set(this, void 0);\n    _PromptCachingBetaMessageStream_resolveConnectedPromise.set(this, () => {});\n    _PromptCachingBetaMessageStream_rejectConnectedPromise.set(this, () => {});\n    _PromptCachingBetaMessageStream_endPromise.set(this, void 0);\n    _PromptCachingBetaMessageStream_resolveEndPromise.set(this, () => {});\n    _PromptCachingBetaMessageStream_rejectEndPromise.set(this, () => {});\n    _PromptCachingBetaMessageStream_listeners.set(this, {});\n    _PromptCachingBetaMessageStream_ended.set(this, false);\n    _PromptCachingBetaMessageStream_errored.set(this, false);\n    _PromptCachingBetaMessageStream_aborted.set(this, false);\n    _PromptCachingBetaMessageStream_catchingPromiseCreated.set(this, false);\n    _PromptCachingBetaMessageStream_handleError.set(this, error => {\n      __classPrivateFieldSet(this, _PromptCachingBetaMessageStream_errored, true, \"f\");\n      if (error instanceof Error && error.name === 'AbortError') {\n        error = new APIUserAbortError();\n      }\n      if (error instanceof APIUserAbortError) {\n        __classPrivateFieldSet(this, _PromptCachingBetaMessageStream_aborted, true, \"f\");\n        return this._emit('abort', error);\n      }\n      if (error instanceof AnthropicError) {\n        return this._emit('error', error);\n      }\n      if (error instanceof Error) {\n        const anthropicError = new AnthropicError(error.message);\n        // @ts-ignore\n        anthropicError.cause = error;\n        return this._emit('error', anthropicError);\n      }\n      return this._emit('error', new AnthropicError(String(error)));\n    });\n    __classPrivateFieldSet(this, _PromptCachingBetaMessageStream_connectedPromise, new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _PromptCachingBetaMessageStream_resolveConnectedPromise, resolve, \"f\");\n      __classPrivateFieldSet(this, _PromptCachingBetaMessageStream_rejectConnectedPromise, reject, \"f\");\n    }), \"f\");\n    __classPrivateFieldSet(this, _PromptCachingBetaMessageStream_endPromise, new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _PromptCachingBetaMessageStream_resolveEndPromise, resolve, \"f\");\n      __classPrivateFieldSet(this, _PromptCachingBetaMessageStream_rejectEndPromise, reject, \"f\");\n    }), \"f\");\n    // Don't let these promises cause unhandled rejection errors.\n    // we will manually cause an unhandled rejection error later\n    // if the user hasn't registered any error listener or called\n    // any promise-returning method.\n    __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_connectedPromise, \"f\").catch(() => {});\n    __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_endPromise, \"f\").catch(() => {});\n  }\n  /**\n   * Intended for use on the frontend, consuming a stream produced with\n   * `.toReadableStream()` on the backend.\n   *\n   * Note that messages sent to the model do not appear in `.on('message')`\n   * in this context.\n   */\n  static fromReadableStream(stream) {\n    const runner = new PromptCachingBetaMessageStream();\n    runner._run(() => runner._fromReadableStream(stream));\n    return runner;\n  }\n  static createMessage(messages, params, options) {\n    const runner = new PromptCachingBetaMessageStream();\n    for (const message of params.messages) {\n      runner._addPromptCachingBetaMessageParam(message);\n    }\n    runner._run(() => runner._createPromptCachingBetaMessage(messages, {\n      ...params,\n      stream: true\n    }, {\n      ...options,\n      headers: {\n        ...options?.headers,\n        'X-Stainless-Helper-Method': 'stream'\n      }\n    }));\n    return runner;\n  }\n  _run(executor) {\n    executor().then(() => {\n      this._emitFinal();\n      this._emit('end');\n    }, __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_handleError, \"f\"));\n  }\n  _addPromptCachingBetaMessageParam(message) {\n    this.messages.push(message);\n  }\n  _addPromptCachingBetaMessage(message, emit = true) {\n    this.receivedMessages.push(message);\n    if (emit) {\n      this._emit('message', message);\n    }\n  }\n  async _createPromptCachingBetaMessage(messages, params, options) {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_instances, \"m\", _PromptCachingBetaMessageStream_beginRequest).call(this);\n    const stream = await messages.create({\n      ...params,\n      stream: true\n    }, {\n      ...options,\n      signal: this.controller.signal\n    });\n    this._connected();\n    for await (const event of stream) {\n      __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_instances, \"m\", _PromptCachingBetaMessageStream_addStreamEvent).call(this, event);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_instances, \"m\", _PromptCachingBetaMessageStream_endRequest).call(this);\n  }\n  _connected() {\n    if (this.ended) return;\n    __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_resolveConnectedPromise, \"f\").call(this);\n    this._emit('connect');\n  }\n  get ended() {\n    return __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_ended, \"f\");\n  }\n  get errored() {\n    return __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_errored, \"f\");\n  }\n  get aborted() {\n    return __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_aborted, \"f\");\n  }\n  abort() {\n    this.controller.abort();\n  }\n  /**\n   * Adds the listener function to the end of the listeners array for the event.\n   * No checks are made to see if the listener has already been added. Multiple calls passing\n   * the same combination of event and listener will result in the listener being added, and\n   * called, multiple times.\n   * @returns this PromptCachingBetaMessageStream, so that calls can be chained\n   */\n  on(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _PromptCachingBetaMessageStream_listeners, \"f\")[event] = []);\n    listeners.push({\n      listener\n    });\n    return this;\n  }\n  /**\n   * Removes the specified listener from the listener array for the event.\n   * off() will remove, at most, one instance of a listener from the listener array. If any single\n   * listener has been added multiple times to the listener array for the specified event, then\n   * off() must be called multiple times to remove each instance.\n   * @returns this PromptCachingBetaMessageStream, so that calls can be chained\n   */\n  off(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_listeners, \"f\")[event];\n    if (!listeners) return this;\n    const index = listeners.findIndex(l => l.listener === listener);\n    if (index >= 0) listeners.splice(index, 1);\n    return this;\n  }\n  /**\n   * Adds a one-time listener function for the event. The next time the event is triggered,\n   * this listener is removed and then invoked.\n   * @returns this PromptCachingBetaMessageStream, so that calls can be chained\n   */\n  once(event, listener) {\n    const listeners = __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_listeners, \"f\")[event] || (__classPrivateFieldGet(this, _PromptCachingBetaMessageStream_listeners, \"f\")[event] = []);\n    listeners.push({\n      listener,\n      once: true\n    });\n    return this;\n  }\n  /**\n   * This is similar to `.once()`, but returns a Promise that resolves the next time\n   * the event is triggered, instead of calling a listener callback.\n   * @returns a Promise that resolves the next time given event is triggered,\n   * or rejects if an error is emitted.  (If you request the 'error' event,\n   * returns a promise that resolves with the error).\n   *\n   * Example:\n   *\n   *   const message = await stream.emitted('message') // rejects if the stream errors\n   */\n  emitted(event) {\n    return new Promise((resolve, reject) => {\n      __classPrivateFieldSet(this, _PromptCachingBetaMessageStream_catchingPromiseCreated, true, \"f\");\n      if (event !== 'error') this.once('error', reject);\n      this.once(event, resolve);\n    });\n  }\n  async done() {\n    __classPrivateFieldSet(this, _PromptCachingBetaMessageStream_catchingPromiseCreated, true, \"f\");\n    await __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_endPromise, \"f\");\n  }\n  get currentMessage() {\n    return __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_currentMessageSnapshot, \"f\");\n  }\n  /**\n   * @returns a promise that resolves with the the final assistant PromptCachingBetaMessage response,\n   * or rejects if an error occurred or the stream ended prematurely without producing a PromptCachingBetaMessage.\n   */\n  async finalMessage() {\n    await this.done();\n    return __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_instances, \"m\", _PromptCachingBetaMessageStream_getFinalMessage).call(this);\n  }\n  /**\n   * @returns a promise that resolves with the the final assistant PromptCachingBetaMessage's text response, concatenated\n   * together if there are more than one text blocks.\n   * Rejects if an error occurred or the stream ended prematurely without producing a PromptCachingBetaMessage.\n   */\n  async finalText() {\n    await this.done();\n    return __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_instances, \"m\", _PromptCachingBetaMessageStream_getFinalText).call(this);\n  }\n  _emit(event, ...args) {\n    // make sure we don't emit any PromptCachingBetaMessageStreamEvents after end\n    if (__classPrivateFieldGet(this, _PromptCachingBetaMessageStream_ended, \"f\")) return;\n    if (event === 'end') {\n      __classPrivateFieldSet(this, _PromptCachingBetaMessageStream_ended, true, \"f\");\n      __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_resolveEndPromise, \"f\").call(this);\n    }\n    const listeners = __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_listeners, \"f\")[event];\n    if (listeners) {\n      __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_listeners, \"f\")[event] = listeners.filter(l => !l.once);\n      listeners.forEach(({\n        listener\n      }) => listener(...args));\n    }\n    if (event === 'abort') {\n      const error = args[0];\n      if (!__classPrivateFieldGet(this, _PromptCachingBetaMessageStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n        Promise.reject(error);\n      }\n      __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_rejectConnectedPromise, \"f\").call(this, error);\n      __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_rejectEndPromise, \"f\").call(this, error);\n      this._emit('end');\n      return;\n    }\n    if (event === 'error') {\n      // NOTE: _emit('error', error) should only be called from #handleError().\n      const error = args[0];\n      if (!__classPrivateFieldGet(this, _PromptCachingBetaMessageStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n        // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n        // If you are seeing stack traces here, make sure to handle errors via either:\n        // - runner.on('error', () => ...)\n        // - await runner.done()\n        // - await runner.final...()\n        // - etc.\n        Promise.reject(error);\n      }\n      __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_rejectConnectedPromise, \"f\").call(this, error);\n      __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_rejectEndPromise, \"f\").call(this, error);\n      this._emit('end');\n    }\n  }\n  _emitFinal() {\n    const finalPromptCachingBetaMessage = this.receivedMessages.at(-1);\n    if (finalPromptCachingBetaMessage) {\n      this._emit('finalPromptCachingBetaMessage', __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_instances, \"m\", _PromptCachingBetaMessageStream_getFinalMessage).call(this));\n    }\n  }\n  async _fromReadableStream(readableStream, options) {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_instances, \"m\", _PromptCachingBetaMessageStream_beginRequest).call(this);\n    this._connected();\n    const stream = Stream.fromReadableStream(readableStream, this.controller);\n    for await (const event of stream) {\n      __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_instances, \"m\", _PromptCachingBetaMessageStream_addStreamEvent).call(this, event);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_instances, \"m\", _PromptCachingBetaMessageStream_endRequest).call(this);\n  }\n  [(_PromptCachingBetaMessageStream_currentMessageSnapshot = new WeakMap(), _PromptCachingBetaMessageStream_connectedPromise = new WeakMap(), _PromptCachingBetaMessageStream_resolveConnectedPromise = new WeakMap(), _PromptCachingBetaMessageStream_rejectConnectedPromise = new WeakMap(), _PromptCachingBetaMessageStream_endPromise = new WeakMap(), _PromptCachingBetaMessageStream_resolveEndPromise = new WeakMap(), _PromptCachingBetaMessageStream_rejectEndPromise = new WeakMap(), _PromptCachingBetaMessageStream_listeners = new WeakMap(), _PromptCachingBetaMessageStream_ended = new WeakMap(), _PromptCachingBetaMessageStream_errored = new WeakMap(), _PromptCachingBetaMessageStream_aborted = new WeakMap(), _PromptCachingBetaMessageStream_catchingPromiseCreated = new WeakMap(), _PromptCachingBetaMessageStream_handleError = new WeakMap(), _PromptCachingBetaMessageStream_instances = new WeakSet(), _PromptCachingBetaMessageStream_getFinalMessage = function _PromptCachingBetaMessageStream_getFinalMessage() {\n    if (this.receivedMessages.length === 0) {\n      throw new AnthropicError('stream ended without producing a PromptCachingBetaMessage with role=assistant');\n    }\n    return this.receivedMessages.at(-1);\n  }, _PromptCachingBetaMessageStream_getFinalText = function _PromptCachingBetaMessageStream_getFinalText() {\n    if (this.receivedMessages.length === 0) {\n      throw new AnthropicError('stream ended without producing a PromptCachingBetaMessage with role=assistant');\n    }\n    const textBlocks = this.receivedMessages.at(-1).content.filter(block => block.type === 'text').map(block => block.text);\n    if (textBlocks.length === 0) {\n      throw new AnthropicError('stream ended without producing a content block with type=text');\n    }\n    return textBlocks.join(' ');\n  }, _PromptCachingBetaMessageStream_beginRequest = function _PromptCachingBetaMessageStream_beginRequest() {\n    if (this.ended) return;\n    __classPrivateFieldSet(this, _PromptCachingBetaMessageStream_currentMessageSnapshot, undefined, \"f\");\n  }, _PromptCachingBetaMessageStream_addStreamEvent = function _PromptCachingBetaMessageStream_addStreamEvent(event) {\n    if (this.ended) return;\n    const messageSnapshot = __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_instances, \"m\", _PromptCachingBetaMessageStream_accumulateMessage).call(this, event);\n    this._emit('streamEvent', event, messageSnapshot);\n    switch (event.type) {\n      case 'content_block_delta':\n        {\n          const content = messageSnapshot.content.at(-1);\n          if (event.delta.type === 'text_delta' && content.type === 'text') {\n            this._emit('text', event.delta.text, content.text || '');\n          } else if (event.delta.type === 'input_json_delta' && content.type === 'tool_use') {\n            if (content.input) {\n              this._emit('inputJson', event.delta.partial_json, content.input);\n            }\n          }\n          break;\n        }\n      case 'message_stop':\n        {\n          this._addPromptCachingBetaMessageParam(messageSnapshot);\n          this._addPromptCachingBetaMessage(messageSnapshot, true);\n          break;\n        }\n      case 'content_block_stop':\n        {\n          this._emit('contentBlock', messageSnapshot.content.at(-1));\n          break;\n        }\n      case 'message_start':\n        {\n          __classPrivateFieldSet(this, _PromptCachingBetaMessageStream_currentMessageSnapshot, messageSnapshot, \"f\");\n          break;\n        }\n      case 'content_block_start':\n      case 'message_delta':\n        break;\n    }\n  }, _PromptCachingBetaMessageStream_endRequest = function _PromptCachingBetaMessageStream_endRequest() {\n    if (this.ended) {\n      throw new AnthropicError(`stream has ended, this shouldn't happen`);\n    }\n    const snapshot = __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_currentMessageSnapshot, \"f\");\n    if (!snapshot) {\n      throw new AnthropicError(`request ended without sending any chunks`);\n    }\n    __classPrivateFieldSet(this, _PromptCachingBetaMessageStream_currentMessageSnapshot, undefined, \"f\");\n    return snapshot;\n  }, _PromptCachingBetaMessageStream_accumulateMessage = function _PromptCachingBetaMessageStream_accumulateMessage(event) {\n    let snapshot = __classPrivateFieldGet(this, _PromptCachingBetaMessageStream_currentMessageSnapshot, \"f\");\n    if (event.type === 'message_start') {\n      if (snapshot) {\n        throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving \"message_stop\"`);\n      }\n      return event.message;\n    }\n    if (!snapshot) {\n      throw new AnthropicError(`Unexpected event order, got ${event.type} before \"message_start\"`);\n    }\n    switch (event.type) {\n      case 'message_stop':\n        return snapshot;\n      case 'message_delta':\n        snapshot.stop_reason = event.delta.stop_reason;\n        snapshot.stop_sequence = event.delta.stop_sequence;\n        snapshot.usage.output_tokens = event.usage.output_tokens;\n        return snapshot;\n      case 'content_block_start':\n        snapshot.content.push(event.content_block);\n        return snapshot;\n      case 'content_block_delta':\n        {\n          const snapshotContent = snapshot.content.at(event.index);\n          if (snapshotContent?.type === 'text' && event.delta.type === 'text_delta') {\n            snapshotContent.text += event.delta.text;\n          } else if (snapshotContent?.type === 'tool_use' && event.delta.type === 'input_json_delta') {\n            // we need to keep track of the raw JSON string as well so that we can\n            // re-parse it for each delta, for now we just store it as an untyped\n            // non-enumerable property on the snapshot\n            let jsonBuf = snapshotContent[JSON_BUF_PROPERTY] || '';\n            jsonBuf += event.delta.partial_json;\n            Object.defineProperty(snapshotContent, JSON_BUF_PROPERTY, {\n              value: jsonBuf,\n              enumerable: false,\n              writable: true\n            });\n            if (jsonBuf) {\n              snapshotContent.input = partialParse(jsonBuf);\n            }\n          }\n          return snapshot;\n        }\n      case 'content_block_stop':\n        return snapshot;\n    }\n  }, Symbol.asyncIterator)]() {\n    const pushQueue = [];\n    const readQueue = [];\n    let done = false;\n    this.on('streamEvent', event => {\n      const reader = readQueue.shift();\n      if (reader) {\n        reader.resolve(event);\n      } else {\n        pushQueue.push(event);\n      }\n    });\n    this.on('end', () => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.resolve(undefined);\n      }\n      readQueue.length = 0;\n    });\n    this.on('abort', err => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n    this.on('error', err => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n    return {\n      next: async () => {\n        if (!pushQueue.length) {\n          if (done) {\n            return {\n              value: undefined,\n              done: true\n            };\n          }\n          return new Promise((resolve, reject) => readQueue.push({\n            resolve,\n            reject\n          })).then(chunk => chunk ? {\n            value: chunk,\n            done: false\n          } : {\n            value: undefined,\n            done: true\n          });\n        }\n        const chunk = pushQueue.shift();\n        return {\n          value: chunk,\n          done: false\n        };\n      },\n      return: async () => {\n        this.abort();\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n    };\n  }\n  toReadableStream() {\n    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n    return stream.toReadableStream();\n  }\n}","map":{"version":3,"names":["AnthropicError","APIUserAbortError","Stream","partialParse","JSON_BUF_PROPERTY","PromptCachingBetaMessageStream","constructor","messages","receivedMessages","_PromptCachingBetaMessageStream_currentMessageSnapshot","set","controller","AbortController","_PromptCachingBetaMessageStream_connectedPromise","_PromptCachingBetaMessageStream_resolveConnectedPromise","_PromptCachingBetaMessageStream_rejectConnectedPromise","_PromptCachingBetaMessageStream_endPromise","_PromptCachingBetaMessageStream_resolveEndPromise","_PromptCachingBetaMessageStream_rejectEndPromise","_PromptCachingBetaMessageStream_listeners","_PromptCachingBetaMessageStream_ended","_PromptCachingBetaMessageStream_errored","_PromptCachingBetaMessageStream_aborted","_PromptCachingBetaMessageStream_catchingPromiseCreated","_PromptCachingBetaMessageStream_handleError","error","__classPrivateFieldSet","Error","name","_emit","anthropicError","message","cause","String","Promise","resolve","reject","__classPrivateFieldGet","catch","fromReadableStream","stream","runner","_run","_fromReadableStream","createMessage","params","options","_addPromptCachingBetaMessageParam","_createPromptCachingBetaMessage","headers","executor","then","_emitFinal","push","_addPromptCachingBetaMessage","emit","signal","aborted","abort","addEventListener","_PromptCachingBetaMessageStream_instances","_PromptCachingBetaMessageStream_beginRequest","call","create","_connected","event","_PromptCachingBetaMessageStream_addStreamEvent","_PromptCachingBetaMessageStream_endRequest","ended","errored","on","listener","listeners","off","index","findIndex","l","splice","once","emitted","done","currentMessage","finalMessage","_PromptCachingBetaMessageStream_getFinalMessage","finalText","_PromptCachingBetaMessageStream_getFinalText","args","filter","forEach","length","finalPromptCachingBetaMessage","at","readableStream","WeakMap","WeakSet","textBlocks","content","block","type","map","text","join","undefined","messageSnapshot","_PromptCachingBetaMessageStream_accumulateMessage","delta","input","partial_json","snapshot","stop_reason","stop_sequence","usage","output_tokens","content_block","snapshotContent","jsonBuf","Object","defineProperty","value","enumerable","writable","Symbol","asyncIterator","pushQueue","readQueue","reader","shift","err","next","chunk","return","toReadableStream","bind"],"sources":["/home/user/srt-translator/node_modules/@anthropic-ai/sdk/src/lib/PromptCachingBetaMessageStream.ts"],"sourcesContent":["import * as Core from \"../core.js\";\nimport { AnthropicError, APIUserAbortError } from \"../error.js\";\nimport { type ContentBlock, type TextBlock } from \"../resources/messages.js\";\nimport {\n  Messages,\n  type PromptCachingBetaMessage,\n  type RawPromptCachingBetaMessageStreamEvent,\n  type PromptCachingBetaMessageParam,\n  type MessageCreateParams,\n  type MessageCreateParamsBase,\n} from \"../resources/beta/prompt-caching/messages.js\";\nimport { type ReadableStream } from \"../_shims/index.js\";\nimport { Stream } from \"../streaming.js\";\nimport { partialParse } from \"../_vendor/partial-json-parser/parser.js\";\n\nexport interface PromptCachingBetaMessageStreamEvents {\n  connect: () => void;\n  streamEvent: (event: RawPromptCachingBetaMessageStreamEvent, snapshot: PromptCachingBetaMessage) => void;\n  text: (textDelta: string, textSnapshot: string) => void;\n  inputJson: (partialJson: string, jsonSnapshot: unknown) => void;\n  message: (message: PromptCachingBetaMessage) => void;\n  contentBlock: (content: ContentBlock) => void;\n  finalPromptCachingBetaMessage: (message: PromptCachingBetaMessage) => void;\n  error: (error: AnthropicError) => void;\n  abort: (error: APIUserAbortError) => void;\n  end: () => void;\n}\n\ntype PromptCachingBetaMessageStreamEventListeners<Event extends keyof PromptCachingBetaMessageStreamEvents> =\n  {\n    listener: PromptCachingBetaMessageStreamEvents[Event];\n    once?: boolean;\n  }[];\n\nconst JSON_BUF_PROPERTY = '__json_buf';\n\nexport class PromptCachingBetaMessageStream implements AsyncIterable<RawPromptCachingBetaMessageStreamEvent> {\n  messages: PromptCachingBetaMessageParam[] = [];\n  receivedMessages: PromptCachingBetaMessage[] = [];\n  #currentMessageSnapshot: PromptCachingBetaMessage | undefined;\n\n  controller: AbortController = new AbortController();\n\n  #connectedPromise: Promise<void>;\n  #resolveConnectedPromise: () => void = () => {};\n  #rejectConnectedPromise: (error: AnthropicError) => void = () => {};\n\n  #endPromise: Promise<void>;\n  #resolveEndPromise: () => void = () => {};\n  #rejectEndPromise: (error: AnthropicError) => void = () => {};\n\n  #listeners: {\n    [Event in keyof PromptCachingBetaMessageStreamEvents]?: PromptCachingBetaMessageStreamEventListeners<Event>;\n  } = {};\n\n  #ended = false;\n  #errored = false;\n  #aborted = false;\n  #catchingPromiseCreated = false;\n\n  constructor() {\n    this.#connectedPromise = new Promise<void>((resolve, reject) => {\n      this.#resolveConnectedPromise = resolve;\n      this.#rejectConnectedPromise = reject;\n    });\n\n    this.#endPromise = new Promise<void>((resolve, reject) => {\n      this.#resolveEndPromise = resolve;\n      this.#rejectEndPromise = reject;\n    });\n\n    // Don't let these promises cause unhandled rejection errors.\n    // we will manually cause an unhandled rejection error later\n    // if the user hasn't registered any error listener or called\n    // any promise-returning method.\n    this.#connectedPromise.catch(() => {});\n    this.#endPromise.catch(() => {});\n  }\n\n  /**\n   * Intended for use on the frontend, consuming a stream produced with\n   * `.toReadableStream()` on the backend.\n   *\n   * Note that messages sent to the model do not appear in `.on('message')`\n   * in this context.\n   */\n  static fromReadableStream(stream: ReadableStream): PromptCachingBetaMessageStream {\n    const runner = new PromptCachingBetaMessageStream();\n    runner._run(() => runner._fromReadableStream(stream));\n    return runner;\n  }\n\n  static createMessage(\n    messages: Messages,\n    params: MessageCreateParamsBase,\n    options?: Core.RequestOptions,\n  ): PromptCachingBetaMessageStream {\n    const runner = new PromptCachingBetaMessageStream();\n    for (const message of params.messages) {\n      runner._addPromptCachingBetaMessageParam(message);\n    }\n    runner._run(() =>\n      runner._createPromptCachingBetaMessage(\n        messages,\n        { ...params, stream: true },\n        { ...options, headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' } },\n      ),\n    );\n    return runner;\n  }\n\n  protected _run(executor: () => Promise<any>) {\n    executor().then(() => {\n      this._emitFinal();\n      this._emit('end');\n    }, this.#handleError);\n  }\n\n  protected _addPromptCachingBetaMessageParam(message: PromptCachingBetaMessageParam) {\n    this.messages.push(message);\n  }\n\n  protected _addPromptCachingBetaMessage(message: PromptCachingBetaMessage, emit = true) {\n    this.receivedMessages.push(message);\n    if (emit) {\n      this._emit('message', message);\n    }\n  }\n\n  protected async _createPromptCachingBetaMessage(\n    messages: Messages,\n    params: MessageCreateParams,\n    options?: Core.RequestOptions,\n  ): Promise<void> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    this.#beginRequest();\n    const stream = await messages.create(\n      { ...params, stream: true },\n      { ...options, signal: this.controller.signal },\n    );\n    this._connected();\n    for await (const event of stream) {\n      this.#addStreamEvent(event);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    this.#endRequest();\n  }\n\n  protected _connected() {\n    if (this.ended) return;\n    this.#resolveConnectedPromise();\n    this._emit('connect');\n  }\n\n  get ended(): boolean {\n    return this.#ended;\n  }\n\n  get errored(): boolean {\n    return this.#errored;\n  }\n\n  get aborted(): boolean {\n    return this.#aborted;\n  }\n\n  abort() {\n    this.controller.abort();\n  }\n\n  /**\n   * Adds the listener function to the end of the listeners array for the event.\n   * No checks are made to see if the listener has already been added. Multiple calls passing\n   * the same combination of event and listener will result in the listener being added, and\n   * called, multiple times.\n   * @returns this PromptCachingBetaMessageStream, so that calls can be chained\n   */\n  on<Event extends keyof PromptCachingBetaMessageStreamEvents>(\n    event: Event,\n    listener: PromptCachingBetaMessageStreamEvents[Event],\n  ): this {\n    const listeners: PromptCachingBetaMessageStreamEventListeners<Event> =\n      this.#listeners[event] || (this.#listeners[event] = []);\n    listeners.push({ listener });\n    return this;\n  }\n\n  /**\n   * Removes the specified listener from the listener array for the event.\n   * off() will remove, at most, one instance of a listener from the listener array. If any single\n   * listener has been added multiple times to the listener array for the specified event, then\n   * off() must be called multiple times to remove each instance.\n   * @returns this PromptCachingBetaMessageStream, so that calls can be chained\n   */\n  off<Event extends keyof PromptCachingBetaMessageStreamEvents>(\n    event: Event,\n    listener: PromptCachingBetaMessageStreamEvents[Event],\n  ): this {\n    const listeners = this.#listeners[event];\n    if (!listeners) return this;\n    const index = listeners.findIndex((l) => l.listener === listener);\n    if (index >= 0) listeners.splice(index, 1);\n    return this;\n  }\n\n  /**\n   * Adds a one-time listener function for the event. The next time the event is triggered,\n   * this listener is removed and then invoked.\n   * @returns this PromptCachingBetaMessageStream, so that calls can be chained\n   */\n  once<Event extends keyof PromptCachingBetaMessageStreamEvents>(\n    event: Event,\n    listener: PromptCachingBetaMessageStreamEvents[Event],\n  ): this {\n    const listeners: PromptCachingBetaMessageStreamEventListeners<Event> =\n      this.#listeners[event] || (this.#listeners[event] = []);\n    listeners.push({ listener, once: true });\n    return this;\n  }\n\n  /**\n   * This is similar to `.once()`, but returns a Promise that resolves the next time\n   * the event is triggered, instead of calling a listener callback.\n   * @returns a Promise that resolves the next time given event is triggered,\n   * or rejects if an error is emitted.  (If you request the 'error' event,\n   * returns a promise that resolves with the error).\n   *\n   * Example:\n   *\n   *   const message = await stream.emitted('message') // rejects if the stream errors\n   */\n  emitted<Event extends keyof PromptCachingBetaMessageStreamEvents>(\n    event: Event,\n  ): Promise<\n    Parameters<PromptCachingBetaMessageStreamEvents[Event]> extends [infer Param] ? Param\n    : Parameters<PromptCachingBetaMessageStreamEvents[Event]> extends [] ? void\n    : Parameters<PromptCachingBetaMessageStreamEvents[Event]>\n  > {\n    return new Promise((resolve, reject) => {\n      this.#catchingPromiseCreated = true;\n      if (event !== 'error') this.once('error', reject);\n      this.once(event, resolve as any);\n    });\n  }\n\n  async done(): Promise<void> {\n    this.#catchingPromiseCreated = true;\n    await this.#endPromise;\n  }\n\n  get currentMessage(): PromptCachingBetaMessage | undefined {\n    return this.#currentMessageSnapshot;\n  }\n\n  #getFinalMessage(): PromptCachingBetaMessage {\n    if (this.receivedMessages.length === 0) {\n      throw new AnthropicError(\n        'stream ended without producing a PromptCachingBetaMessage with role=assistant',\n      );\n    }\n    return this.receivedMessages.at(-1)!;\n  }\n\n  /**\n   * @returns a promise that resolves with the the final assistant PromptCachingBetaMessage response,\n   * or rejects if an error occurred or the stream ended prematurely without producing a PromptCachingBetaMessage.\n   */\n  async finalMessage(): Promise<PromptCachingBetaMessage> {\n    await this.done();\n    return this.#getFinalMessage();\n  }\n\n  #getFinalText(): string {\n    if (this.receivedMessages.length === 0) {\n      throw new AnthropicError(\n        'stream ended without producing a PromptCachingBetaMessage with role=assistant',\n      );\n    }\n    const textBlocks = this.receivedMessages\n      .at(-1)!\n      .content.filter((block): block is TextBlock => block.type === 'text')\n      .map((block) => block.text);\n    if (textBlocks.length === 0) {\n      throw new AnthropicError('stream ended without producing a content block with type=text');\n    }\n    return textBlocks.join(' ');\n  }\n\n  /**\n   * @returns a promise that resolves with the the final assistant PromptCachingBetaMessage's text response, concatenated\n   * together if there are more than one text blocks.\n   * Rejects if an error occurred or the stream ended prematurely without producing a PromptCachingBetaMessage.\n   */\n  async finalText(): Promise<string> {\n    await this.done();\n    return this.#getFinalText();\n  }\n\n  #handleError = (error: unknown) => {\n    this.#errored = true;\n    if (error instanceof Error && error.name === 'AbortError') {\n      error = new APIUserAbortError();\n    }\n    if (error instanceof APIUserAbortError) {\n      this.#aborted = true;\n      return this._emit('abort', error);\n    }\n    if (error instanceof AnthropicError) {\n      return this._emit('error', error);\n    }\n    if (error instanceof Error) {\n      const anthropicError: AnthropicError = new AnthropicError(error.message);\n      // @ts-ignore\n      anthropicError.cause = error;\n      return this._emit('error', anthropicError);\n    }\n    return this._emit('error', new AnthropicError(String(error)));\n  };\n\n  protected _emit<Event extends keyof PromptCachingBetaMessageStreamEvents>(\n    event: Event,\n    ...args: Parameters<PromptCachingBetaMessageStreamEvents[Event]>\n  ) {\n    // make sure we don't emit any PromptCachingBetaMessageStreamEvents after end\n    if (this.#ended) return;\n\n    if (event === 'end') {\n      this.#ended = true;\n      this.#resolveEndPromise();\n    }\n\n    const listeners: PromptCachingBetaMessageStreamEventListeners<Event> | undefined = this.#listeners[event];\n    if (listeners) {\n      this.#listeners[event] = listeners.filter((l) => !l.once) as any;\n      listeners.forEach(({ listener }: any) => listener(...args));\n    }\n\n    if (event === 'abort') {\n      const error = args[0] as APIUserAbortError;\n      if (!this.#catchingPromiseCreated && !listeners?.length) {\n        Promise.reject(error);\n      }\n      this.#rejectConnectedPromise(error);\n      this.#rejectEndPromise(error);\n      this._emit('end');\n      return;\n    }\n\n    if (event === 'error') {\n      // NOTE: _emit('error', error) should only be called from #handleError().\n\n      const error = args[0] as AnthropicError;\n      if (!this.#catchingPromiseCreated && !listeners?.length) {\n        // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n        // If you are seeing stack traces here, make sure to handle errors via either:\n        // - runner.on('error', () => ...)\n        // - await runner.done()\n        // - await runner.final...()\n        // - etc.\n        Promise.reject(error);\n      }\n      this.#rejectConnectedPromise(error);\n      this.#rejectEndPromise(error);\n      this._emit('end');\n    }\n  }\n\n  protected _emitFinal() {\n    const finalPromptCachingBetaMessage = this.receivedMessages.at(-1);\n    if (finalPromptCachingBetaMessage) {\n      this._emit('finalPromptCachingBetaMessage', this.#getFinalMessage());\n    }\n  }\n\n  #beginRequest() {\n    if (this.ended) return;\n    this.#currentMessageSnapshot = undefined;\n  }\n  #addStreamEvent(event: RawPromptCachingBetaMessageStreamEvent) {\n    if (this.ended) return;\n    const messageSnapshot = this.#accumulateMessage(event);\n    this._emit('streamEvent', event, messageSnapshot);\n\n    switch (event.type) {\n      case 'content_block_delta': {\n        const content = messageSnapshot.content.at(-1)!;\n        if (event.delta.type === 'text_delta' && content.type === 'text') {\n          this._emit('text', event.delta.text, content.text || '');\n        } else if (event.delta.type === 'input_json_delta' && content.type === 'tool_use') {\n          if (content.input) {\n            this._emit('inputJson', event.delta.partial_json, content.input);\n          }\n        }\n        break;\n      }\n      case 'message_stop': {\n        this._addPromptCachingBetaMessageParam(messageSnapshot);\n        this._addPromptCachingBetaMessage(messageSnapshot, true);\n        break;\n      }\n      case 'content_block_stop': {\n        this._emit('contentBlock', messageSnapshot.content.at(-1)!);\n        break;\n      }\n      case 'message_start': {\n        this.#currentMessageSnapshot = messageSnapshot;\n        break;\n      }\n      case 'content_block_start':\n      case 'message_delta':\n        break;\n    }\n  }\n  #endRequest(): PromptCachingBetaMessage {\n    if (this.ended) {\n      throw new AnthropicError(`stream has ended, this shouldn't happen`);\n    }\n    const snapshot = this.#currentMessageSnapshot;\n    if (!snapshot) {\n      throw new AnthropicError(`request ended without sending any chunks`);\n    }\n    this.#currentMessageSnapshot = undefined;\n    return snapshot;\n  }\n\n  protected async _fromReadableStream(\n    readableStream: ReadableStream,\n    options?: Core.RequestOptions,\n  ): Promise<void> {\n    const signal = options?.signal;\n    if (signal) {\n      if (signal.aborted) this.controller.abort();\n      signal.addEventListener('abort', () => this.controller.abort());\n    }\n    this.#beginRequest();\n    this._connected();\n    const stream = Stream.fromReadableStream<RawPromptCachingBetaMessageStreamEvent>(\n      readableStream,\n      this.controller,\n    );\n    for await (const event of stream) {\n      this.#addStreamEvent(event);\n    }\n    if (stream.controller.signal?.aborted) {\n      throw new APIUserAbortError();\n    }\n    this.#endRequest();\n  }\n\n  /**\n   * Mutates this.#currentPromptCachingBetaMessage with the current event. Handling the accumulation of multiple messages\n   * will be needed to be handled by the caller, this method will throw if you try to accumulate for multiple\n   * messages.\n   */\n  #accumulateMessage(event: RawPromptCachingBetaMessageStreamEvent): PromptCachingBetaMessage {\n    let snapshot = this.#currentMessageSnapshot;\n\n    if (event.type === 'message_start') {\n      if (snapshot) {\n        throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving \"message_stop\"`);\n      }\n      return event.message;\n    }\n\n    if (!snapshot) {\n      throw new AnthropicError(`Unexpected event order, got ${event.type} before \"message_start\"`);\n    }\n\n    switch (event.type) {\n      case 'message_stop':\n        return snapshot;\n      case 'message_delta':\n        snapshot.stop_reason = event.delta.stop_reason;\n        snapshot.stop_sequence = event.delta.stop_sequence;\n        snapshot.usage.output_tokens = event.usage.output_tokens;\n        return snapshot;\n      case 'content_block_start':\n        snapshot.content.push(event.content_block);\n        return snapshot;\n      case 'content_block_delta': {\n        const snapshotContent = snapshot.content.at(event.index);\n        if (snapshotContent?.type === 'text' && event.delta.type === 'text_delta') {\n          snapshotContent.text += event.delta.text;\n        } else if (snapshotContent?.type === 'tool_use' && event.delta.type === 'input_json_delta') {\n          // we need to keep track of the raw JSON string as well so that we can\n          // re-parse it for each delta, for now we just store it as an untyped\n          // non-enumerable property on the snapshot\n          let jsonBuf = (snapshotContent as any)[JSON_BUF_PROPERTY] || '';\n          jsonBuf += event.delta.partial_json;\n\n          Object.defineProperty(snapshotContent, JSON_BUF_PROPERTY, {\n            value: jsonBuf,\n            enumerable: false,\n            writable: true,\n          });\n\n          if (jsonBuf) {\n            snapshotContent.input = partialParse(jsonBuf);\n          }\n        }\n        return snapshot;\n      }\n      case 'content_block_stop':\n        return snapshot;\n    }\n  }\n\n  [Symbol.asyncIterator](): AsyncIterator<RawPromptCachingBetaMessageStreamEvent> {\n    const pushQueue: RawPromptCachingBetaMessageStreamEvent[] = [];\n    const readQueue: {\n      resolve: (chunk: RawPromptCachingBetaMessageStreamEvent | undefined) => void;\n      reject: (error: unknown) => void;\n    }[] = [];\n    let done = false;\n\n    this.on('streamEvent', (event) => {\n      const reader = readQueue.shift();\n      if (reader) {\n        reader.resolve(event);\n      } else {\n        pushQueue.push(event);\n      }\n    });\n\n    this.on('end', () => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.resolve(undefined);\n      }\n      readQueue.length = 0;\n    });\n\n    this.on('abort', (err) => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n\n    this.on('error', (err) => {\n      done = true;\n      for (const reader of readQueue) {\n        reader.reject(err);\n      }\n      readQueue.length = 0;\n    });\n\n    return {\n      next: async (): Promise<IteratorResult<RawPromptCachingBetaMessageStreamEvent>> => {\n        if (!pushQueue.length) {\n          if (done) {\n            return { value: undefined, done: true };\n          }\n          return new Promise<RawPromptCachingBetaMessageStreamEvent | undefined>((resolve, reject) =>\n            readQueue.push({ resolve, reject }),\n          ).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\n        }\n        const chunk = pushQueue.shift()!;\n        return { value: chunk, done: false };\n      },\n      return: async () => {\n        this.abort();\n        return { value: undefined, done: true };\n      },\n    };\n  }\n\n  toReadableStream(): ReadableStream {\n    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n    return stream.toReadableStream();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
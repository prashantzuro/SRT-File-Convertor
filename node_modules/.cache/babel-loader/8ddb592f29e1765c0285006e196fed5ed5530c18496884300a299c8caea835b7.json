{"ast":null,"code":"export const translateSrt = async (fileContent, apiKey, language) => {\n  const maxRetries = 8; // Increased max retries\n  const baseDelay = 5000; // Increased initial delay to 5 seconds\n  const maxDelay = 60000; // Maximum delay of 60 seconds\n\n  const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\n  for (let retryCount = 0; retryCount < maxRetries; retryCount++) {\n    try {\n      var _data$choices, _data$choices$, _data$choices$$messag;\n      console.log(`Attempt ${retryCount + 1}: Sending translation request...`);\n      const response = await fetch(\"https://api.openai.com/v1/chat/completions\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${apiKey}`\n        },\n        body: JSON.stringify({\n          model: \"gpt-4\",\n          messages: [{\n            role: \"system\",\n            content: `You are an SRT translator. Translate the following subtitles to ${language}:`\n          }, {\n            role: \"user\",\n            content: fileContent\n          }]\n        })\n      });\n      if (response.status === 429) {\n        // Get retry-after header or calculate exponential backoff\n        const retryAfter = response.headers.get(\"Retry-After\");\n        let delay;\n        if (retryAfter) {\n          delay = parseInt(retryAfter, 10) * 1000;\n        } else {\n          delay = Math.min(baseDelay * Math.pow(2, retryCount), maxDelay);\n        }\n        console.warn(`Rate limit exceeded. Waiting ${delay / 1000} seconds before retry...`);\n        await sleep(delay);\n        continue;\n      }\n      if (!response.ok) {\n        const errorBody = await response.text();\n        throw new Error(`API Request failed with status ${response.status}: ${errorBody}`);\n      }\n      const data = await response.json();\n      const translatedText = data === null || data === void 0 ? void 0 : (_data$choices = data.choices) === null || _data$choices === void 0 ? void 0 : (_data$choices$ = _data$choices[0]) === null || _data$choices$ === void 0 ? void 0 : (_data$choices$$messag = _data$choices$.message) === null || _data$choices$$messag === void 0 ? void 0 : _data$choices$$messag.content;\n      if (!translatedText) {\n        throw new Error(\"Received empty translation result from API\");\n      }\n      console.log(\"Translation successful!\");\n      return translatedText;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';\n      console.error(`Attempt ${retryCount + 1} failed: ${errorMessage}`);\n      if (retryCount === maxRetries - 1) {\n        throw new Error(`Translation failed after ${maxRetries} attempts: ${errorMessage}`);\n      }\n\n      // Add delay even for non-429 errors\n      const delay = Math.min(baseDelay * Math.pow(2, retryCount), maxDelay);\n      console.log(`Waiting ${delay / 1000} seconds before retry...`);\n      await sleep(delay);\n    }\n  }\n  throw new Error(\"Translation failed: No successful response after all retries\");\n};","map":{"version":3,"names":["translateSrt","fileContent","apiKey","language","maxRetries","baseDelay","maxDelay","sleep","ms","Promise","resolve","setTimeout","retryCount","_data$choices","_data$choices$","_data$choices$$messag","console","log","response","fetch","method","headers","Authorization","body","JSON","stringify","model","messages","role","content","status","retryAfter","get","delay","parseInt","Math","min","pow","warn","ok","errorBody","text","Error","data","json","translatedText","choices","message","error","errorMessage"],"sources":["/home/user/srt-translator/src/utils/translateSrt.ts"],"sourcesContent":["export const translateSrt = async (\n  fileContent: string,\n  apiKey: string,\n  language: string\n): Promise<string> => {\n  const maxRetries = 8; // Increased max retries\n  const baseDelay = 5000; // Increased initial delay to 5 seconds\n  const maxDelay = 60000; // Maximum delay of 60 seconds\n\n  const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\n  for (let retryCount = 0; retryCount < maxRetries; retryCount++) {\n    try {\n      console.log(`Attempt ${retryCount + 1}: Sending translation request...`);\n\n      const response = await fetch(\"https://api.openai.com/v1/chat/completions\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: `Bearer ${apiKey}`,\n        },\n        body: JSON.stringify({\n          model: \"gpt-4\",\n          messages: [\n            {\n              role: \"system\",\n              content: `You are an SRT translator. Translate the following subtitles to ${language}:`,\n            },\n            { role: \"user\", content: fileContent },\n          ],\n        }),\n      });\n\n      if (response.status === 429) {\n        // Get retry-after header or calculate exponential backoff\n        const retryAfter = response.headers.get(\"Retry-After\");\n        let delay: number;\n\n        if (retryAfter) {\n          delay = parseInt(retryAfter, 10) * 1000;\n        } else {\n          delay = Math.min(baseDelay * Math.pow(2, retryCount), maxDelay);\n        }\n\n        console.warn(`Rate limit exceeded. Waiting ${delay/1000} seconds before retry...`);\n        await sleep(delay);\n        continue;\n      }\n\n      if (!response.ok) {\n        const errorBody = await response.text();\n        throw new Error(`API Request failed with status ${response.status}: ${errorBody}`);\n      }\n\n      const data = await response.json();\n      const translatedText = data?.choices?.[0]?.message?.content;\n\n      if (!translatedText) {\n        throw new Error(\"Received empty translation result from API\");\n      }\n\n      console.log(\"Translation successful!\");\n      return translatedText;\n\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';\n      console.error(`Attempt ${retryCount + 1} failed: ${errorMessage}`);\n\n      if (retryCount === maxRetries - 1) {\n        throw new Error(`Translation failed after ${maxRetries} attempts: ${errorMessage}`);\n      }\n\n      // Add delay even for non-429 errors\n      const delay = Math.min(baseDelay * Math.pow(2, retryCount), maxDelay);\n      console.log(`Waiting ${delay/1000} seconds before retry...`);\n      await sleep(delay);\n    }\n  }\n\n  throw new Error(\"Translation failed: No successful response after all retries\");\n};"],"mappings":"AAAA,OAAO,MAAMA,YAAY,GAAG,MAAAA,CAC1BC,WAAmB,EACnBC,MAAc,EACdC,QAAgB,KACI;EACpB,MAAMC,UAAU,GAAG,CAAC,CAAC,CAAC;EACtB,MAAMC,SAAS,GAAG,IAAI,CAAC,CAAC;EACxB,MAAMC,QAAQ,GAAG,KAAK,CAAC,CAAC;;EAExB,MAAMC,KAAK,GAAIC,EAAU,IAAK,IAAIC,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAEF,EAAE,CAAC,CAAC;EAE7E,KAAK,IAAII,UAAU,GAAG,CAAC,EAAEA,UAAU,GAAGR,UAAU,EAAEQ,UAAU,EAAE,EAAE;IAC9D,IAAI;MAAA,IAAAC,aAAA,EAAAC,cAAA,EAAAC,qBAAA;MACFC,OAAO,CAACC,GAAG,CAAC,WAAWL,UAAU,GAAG,CAAC,kCAAkC,CAAC;MAExE,MAAMM,QAAQ,GAAG,MAAMC,KAAK,CAAC,4CAA4C,EAAE;QACzEC,MAAM,EAAE,MAAM;QACdC,OAAO,EAAE;UACP,cAAc,EAAE,kBAAkB;UAClCC,aAAa,EAAE,UAAUpB,MAAM;QACjC,CAAC;QACDqB,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;UACnBC,KAAK,EAAE,OAAO;UACdC,QAAQ,EAAE,CACR;YACEC,IAAI,EAAE,QAAQ;YACdC,OAAO,EAAE,mEAAmE1B,QAAQ;UACtF,CAAC,EACD;YAAEyB,IAAI,EAAE,MAAM;YAAEC,OAAO,EAAE5B;UAAY,CAAC;QAE1C,CAAC;MACH,CAAC,CAAC;MAEF,IAAIiB,QAAQ,CAACY,MAAM,KAAK,GAAG,EAAE;QAC3B;QACA,MAAMC,UAAU,GAAGb,QAAQ,CAACG,OAAO,CAACW,GAAG,CAAC,aAAa,CAAC;QACtD,IAAIC,KAAa;QAEjB,IAAIF,UAAU,EAAE;UACdE,KAAK,GAAGC,QAAQ,CAACH,UAAU,EAAE,EAAE,CAAC,GAAG,IAAI;QACzC,CAAC,MAAM;UACLE,KAAK,GAAGE,IAAI,CAACC,GAAG,CAAC/B,SAAS,GAAG8B,IAAI,CAACE,GAAG,CAAC,CAAC,EAAEzB,UAAU,CAAC,EAAEN,QAAQ,CAAC;QACjE;QAEAU,OAAO,CAACsB,IAAI,CAAC,gCAAgCL,KAAK,GAAC,IAAI,0BAA0B,CAAC;QAClF,MAAM1B,KAAK,CAAC0B,KAAK,CAAC;QAClB;MACF;MAEA,IAAI,CAACf,QAAQ,CAACqB,EAAE,EAAE;QAChB,MAAMC,SAAS,GAAG,MAAMtB,QAAQ,CAACuB,IAAI,CAAC,CAAC;QACvC,MAAM,IAAIC,KAAK,CAAC,kCAAkCxB,QAAQ,CAACY,MAAM,KAAKU,SAAS,EAAE,CAAC;MACpF;MAEA,MAAMG,IAAI,GAAG,MAAMzB,QAAQ,CAAC0B,IAAI,CAAC,CAAC;MAClC,MAAMC,cAAc,GAAGF,IAAI,aAAJA,IAAI,wBAAA9B,aAAA,GAAJ8B,IAAI,CAAEG,OAAO,cAAAjC,aAAA,wBAAAC,cAAA,GAAbD,aAAA,CAAgB,CAAC,CAAC,cAAAC,cAAA,wBAAAC,qBAAA,GAAlBD,cAAA,CAAoBiC,OAAO,cAAAhC,qBAAA,uBAA3BA,qBAAA,CAA6Bc,OAAO;MAE3D,IAAI,CAACgB,cAAc,EAAE;QACnB,MAAM,IAAIH,KAAK,CAAC,4CAA4C,CAAC;MAC/D;MAEA1B,OAAO,CAACC,GAAG,CAAC,yBAAyB,CAAC;MACtC,OAAO4B,cAAc;IAEvB,CAAC,CAAC,OAAOG,KAAK,EAAE;MACd,MAAMC,YAAY,GAAGD,KAAK,YAAYN,KAAK,GAAGM,KAAK,CAACD,OAAO,GAAG,wBAAwB;MACtF/B,OAAO,CAACgC,KAAK,CAAC,WAAWpC,UAAU,GAAG,CAAC,YAAYqC,YAAY,EAAE,CAAC;MAElE,IAAIrC,UAAU,KAAKR,UAAU,GAAG,CAAC,EAAE;QACjC,MAAM,IAAIsC,KAAK,CAAC,4BAA4BtC,UAAU,cAAc6C,YAAY,EAAE,CAAC;MACrF;;MAEA;MACA,MAAMhB,KAAK,GAAGE,IAAI,CAACC,GAAG,CAAC/B,SAAS,GAAG8B,IAAI,CAACE,GAAG,CAAC,CAAC,EAAEzB,UAAU,CAAC,EAAEN,QAAQ,CAAC;MACrEU,OAAO,CAACC,GAAG,CAAC,WAAWgB,KAAK,GAAC,IAAI,0BAA0B,CAAC;MAC5D,MAAM1B,KAAK,CAAC0B,KAAK,CAAC;IACpB;EACF;EAEA,MAAM,IAAIS,KAAK,CAAC,8DAA8D,CAAC;AACjF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
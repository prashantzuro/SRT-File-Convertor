{"ast":null,"code":"import { ReadableStream } from \"./_shims/index.mjs\";\nimport { AnthropicError } from \"./error.mjs\";\nimport { LineDecoder } from \"./internal/decoders/line.mjs\";\nimport { createResponseHeaders } from \"./core.mjs\";\nimport { APIError } from \"./error.mjs\";\nexport class Stream {\n  constructor(iterator, controller) {\n    this.iterator = iterator;\n    this.controller = controller;\n  }\n  static fromSSEResponse(response, controller) {\n    let consumed = false;\n    async function* iterator() {\n      if (consumed) {\n        throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n      }\n      consumed = true;\n      let done = false;\n      try {\n        for await (const sse of _iterSSEMessages(response, controller)) {\n          if (sse.event === 'completion') {\n            try {\n              yield JSON.parse(sse.data);\n            } catch (e) {\n              console.error(`Could not parse message into JSON:`, sse.data);\n              console.error(`From chunk:`, sse.raw);\n              throw e;\n            }\n          }\n          if (sse.event === 'message_start' || sse.event === 'message_delta' || sse.event === 'message_stop' || sse.event === 'content_block_start' || sse.event === 'content_block_delta' || sse.event === 'content_block_stop') {\n            try {\n              yield JSON.parse(sse.data);\n            } catch (e) {\n              console.error(`Could not parse message into JSON:`, sse.data);\n              console.error(`From chunk:`, sse.raw);\n              throw e;\n            }\n          }\n          if (sse.event === 'ping') {\n            continue;\n          }\n          if (sse.event === 'error') {\n            throw APIError.generate(undefined, `SSE Error: ${sse.data}`, sse.data, createResponseHeaders(response.headers));\n          }\n        }\n        done = true;\n      } catch (e) {\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\n        if (e instanceof Error && e.name === 'AbortError') return;\n        throw e;\n      } finally {\n        // If the user `break`s, abort the ongoing request.\n        if (!done) controller.abort();\n      }\n    }\n    return new Stream(iterator, controller);\n  }\n  /**\n   * Generates a Stream from a newline-separated ReadableStream\n   * where each item is a JSON value.\n   */\n  static fromReadableStream(readableStream, controller) {\n    let consumed = false;\n    async function* iterLines() {\n      const lineDecoder = new LineDecoder();\n      const iter = readableStreamAsyncIterable(readableStream);\n      for await (const chunk of iter) {\n        for (const line of lineDecoder.decode(chunk)) {\n          yield line;\n        }\n      }\n      for (const line of lineDecoder.flush()) {\n        yield line;\n      }\n    }\n    async function* iterator() {\n      if (consumed) {\n        throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n      }\n      consumed = true;\n      let done = false;\n      try {\n        for await (const line of iterLines()) {\n          if (done) continue;\n          if (line) yield JSON.parse(line);\n        }\n        done = true;\n      } catch (e) {\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\n        if (e instanceof Error && e.name === 'AbortError') return;\n        throw e;\n      } finally {\n        // If the user `break`s, abort the ongoing request.\n        if (!done) controller.abort();\n      }\n    }\n    return new Stream(iterator, controller);\n  }\n  [Symbol.asyncIterator]() {\n    return this.iterator();\n  }\n  /**\n   * Splits the stream into two streams which can be\n   * independently read from at different speeds.\n   */\n  tee() {\n    const left = [];\n    const right = [];\n    const iterator = this.iterator();\n    const teeIterator = queue => {\n      return {\n        next: () => {\n          if (queue.length === 0) {\n            const result = iterator.next();\n            left.push(result);\n            right.push(result);\n          }\n          return queue.shift();\n        }\n      };\n    };\n    return [new Stream(() => teeIterator(left), this.controller), new Stream(() => teeIterator(right), this.controller)];\n  }\n  /**\n   * Converts this stream to a newline-separated ReadableStream of\n   * JSON stringified values in the stream\n   * which can be turned back into a Stream with `Stream.fromReadableStream()`.\n   */\n  toReadableStream() {\n    const self = this;\n    let iter;\n    const encoder = new TextEncoder();\n    return new ReadableStream({\n      async start() {\n        iter = self[Symbol.asyncIterator]();\n      },\n      async pull(ctrl) {\n        try {\n          const {\n            value,\n            done\n          } = await iter.next();\n          if (done) return ctrl.close();\n          const bytes = encoder.encode(JSON.stringify(value) + '\\n');\n          ctrl.enqueue(bytes);\n        } catch (err) {\n          ctrl.error(err);\n        }\n      },\n      async cancel() {\n        await iter.return?.();\n      }\n    });\n  }\n}\nexport async function* _iterSSEMessages(response, controller) {\n  if (!response.body) {\n    controller.abort();\n    throw new AnthropicError(`Attempted to iterate over a response with no body`);\n  }\n  const sseDecoder = new SSEDecoder();\n  const lineDecoder = new LineDecoder();\n  const iter = readableStreamAsyncIterable(response.body);\n  for await (const sseChunk of iterSSEChunks(iter)) {\n    for (const line of lineDecoder.decode(sseChunk)) {\n      const sse = sseDecoder.decode(line);\n      if (sse) yield sse;\n    }\n  }\n  for (const line of lineDecoder.flush()) {\n    const sse = sseDecoder.decode(line);\n    if (sse) yield sse;\n  }\n}\n/**\n * Given an async iterable iterator, iterates over it and yields full\n * SSE chunks, i.e. yields when a double new-line is encountered.\n */\nasync function* iterSSEChunks(iterator) {\n  let data = new Uint8Array();\n  for await (const chunk of iterator) {\n    if (chunk == null) {\n      continue;\n    }\n    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === 'string' ? new TextEncoder().encode(chunk) : chunk;\n    let newData = new Uint8Array(data.length + binaryChunk.length);\n    newData.set(data);\n    newData.set(binaryChunk, data.length);\n    data = newData;\n    let patternIndex;\n    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {\n      yield data.slice(0, patternIndex);\n      data = data.slice(patternIndex);\n    }\n  }\n  if (data.length > 0) {\n    yield data;\n  }\n}\nfunction findDoubleNewlineIndex(buffer) {\n  // This function searches the buffer for the end patterns (\\r\\r, \\n\\n, \\r\\n\\r\\n)\n  // and returns the index right after the first occurrence of any pattern,\n  // or -1 if none of the patterns are found.\n  const newline = 0x0a; // \\n\n  const carriage = 0x0d; // \\r\n  for (let i = 0; i < buffer.length - 2; i++) {\n    if (buffer[i] === newline && buffer[i + 1] === newline) {\n      // \\n\\n\n      return i + 2;\n    }\n    if (buffer[i] === carriage && buffer[i + 1] === carriage) {\n      // \\r\\r\n      return i + 2;\n    }\n    if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {\n      // \\r\\n\\r\\n\n      return i + 4;\n    }\n  }\n  return -1;\n}\nclass SSEDecoder {\n  constructor() {\n    this.event = null;\n    this.data = [];\n    this.chunks = [];\n  }\n  decode(line) {\n    if (line.endsWith('\\r')) {\n      line = line.substring(0, line.length - 1);\n    }\n    if (!line) {\n      // empty line and we didn't previously encounter any messages\n      if (!this.event && !this.data.length) return null;\n      const sse = {\n        event: this.event,\n        data: this.data.join('\\n'),\n        raw: this.chunks\n      };\n      this.event = null;\n      this.data = [];\n      this.chunks = [];\n      return sse;\n    }\n    this.chunks.push(line);\n    if (line.startsWith(':')) {\n      return null;\n    }\n    let [fieldname, _, value] = partition(line, ':');\n    if (value.startsWith(' ')) {\n      value = value.substring(1);\n    }\n    if (fieldname === 'event') {\n      this.event = value;\n    } else if (fieldname === 'data') {\n      this.data.push(value);\n    }\n    return null;\n  }\n}\n/** This is an internal helper function that's just used for testing */\nexport function _decodeChunks(chunks) {\n  const decoder = new LineDecoder();\n  const lines = [];\n  for (const chunk of chunks) {\n    lines.push(...decoder.decode(chunk));\n  }\n  return lines;\n}\nfunction partition(str, delimiter) {\n  const index = str.indexOf(delimiter);\n  if (index !== -1) {\n    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\n  }\n  return [str, '', ''];\n}\n/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nexport function readableStreamAsyncIterable(stream) {\n  if (stream[Symbol.asyncIterator]) return stream;\n  const reader = stream.getReader();\n  return {\n    async next() {\n      try {\n        const result = await reader.read();\n        if (result?.done) reader.releaseLock(); // release lock when stream becomes closed\n        return result;\n      } catch (e) {\n        reader.releaseLock(); // release lock when stream becomes errored\n        throw e;\n      }\n    },\n    async return() {\n      const cancelPromise = reader.cancel();\n      reader.releaseLock();\n      await cancelPromise;\n      return {\n        done: true,\n        value: undefined\n      };\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n  };\n}","map":{"version":3,"names":["ReadableStream","AnthropicError","LineDecoder","createResponseHeaders","APIError","Stream","constructor","iterator","controller","fromSSEResponse","response","consumed","Error","done","sse","_iterSSEMessages","event","JSON","parse","data","e","console","error","raw","generate","undefined","headers","name","abort","fromReadableStream","readableStream","iterLines","lineDecoder","iter","readableStreamAsyncIterable","chunk","line","decode","flush","Symbol","asyncIterator","tee","left","right","teeIterator","queue","next","length","result","push","shift","toReadableStream","self","encoder","TextEncoder","start","pull","ctrl","value","close","bytes","encode","stringify","enqueue","err","cancel","return","body","sseDecoder","SSEDecoder","sseChunk","iterSSEChunks","Uint8Array","binaryChunk","ArrayBuffer","newData","set","patternIndex","findDoubleNewlineIndex","slice","buffer","newline","carriage","i","chunks","endsWith","substring","join","startsWith","fieldname","_","partition","_decodeChunks","decoder","lines","str","delimiter","index","indexOf","stream","reader","getReader","read","releaseLock","cancelPromise"],"sources":["/home/user/srt-translator/node_modules/@anthropic-ai/sdk/src/streaming.ts"],"sourcesContent":["import { ReadableStream, type Response } from \"./_shims/index.js\";\nimport { AnthropicError } from \"./error.js\";\nimport { LineDecoder } from \"./internal/decoders/line.js\";\n\nimport { createResponseHeaders } from \"./core.js\";\nimport { APIError } from \"./error.js\";\n\ntype Bytes = string | ArrayBuffer | Uint8Array | Buffer | null | undefined;\n\nexport type ServerSentEvent = {\n  event: string | null;\n  data: string;\n  raw: string[];\n};\n\nexport class Stream<Item> implements AsyncIterable<Item> {\n  controller: AbortController;\n\n  constructor(\n    private iterator: () => AsyncIterator<Item>,\n    controller: AbortController,\n  ) {\n    this.controller = controller;\n  }\n\n  static fromSSEResponse<Item>(response: Response, controller: AbortController): Stream<Item> {\n    let consumed = false;\n\n    async function* iterator(): AsyncIterator<Item, any, undefined> {\n      if (consumed) {\n        throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n      }\n      consumed = true;\n      let done = false;\n      try {\n        for await (const sse of _iterSSEMessages(response, controller)) {\n          if (sse.event === 'completion') {\n            try {\n              yield JSON.parse(sse.data);\n            } catch (e) {\n              console.error(`Could not parse message into JSON:`, sse.data);\n              console.error(`From chunk:`, sse.raw);\n              throw e;\n            }\n          }\n\n          if (\n            sse.event === 'message_start' ||\n            sse.event === 'message_delta' ||\n            sse.event === 'message_stop' ||\n            sse.event === 'content_block_start' ||\n            sse.event === 'content_block_delta' ||\n            sse.event === 'content_block_stop'\n          ) {\n            try {\n              yield JSON.parse(sse.data);\n            } catch (e) {\n              console.error(`Could not parse message into JSON:`, sse.data);\n              console.error(`From chunk:`, sse.raw);\n              throw e;\n            }\n          }\n\n          if (sse.event === 'ping') {\n            continue;\n          }\n\n          if (sse.event === 'error') {\n            throw APIError.generate(\n              undefined,\n              `SSE Error: ${sse.data}`,\n              sse.data,\n              createResponseHeaders(response.headers),\n            );\n          }\n        }\n        done = true;\n      } catch (e) {\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\n        if (e instanceof Error && e.name === 'AbortError') return;\n        throw e;\n      } finally {\n        // If the user `break`s, abort the ongoing request.\n        if (!done) controller.abort();\n      }\n    }\n\n    return new Stream(iterator, controller);\n  }\n\n  /**\n   * Generates a Stream from a newline-separated ReadableStream\n   * where each item is a JSON value.\n   */\n  static fromReadableStream<Item>(readableStream: ReadableStream, controller: AbortController): Stream<Item> {\n    let consumed = false;\n\n    async function* iterLines(): AsyncGenerator<string, void, unknown> {\n      const lineDecoder = new LineDecoder();\n\n      const iter = readableStreamAsyncIterable<Bytes>(readableStream);\n      for await (const chunk of iter) {\n        for (const line of lineDecoder.decode(chunk)) {\n          yield line;\n        }\n      }\n\n      for (const line of lineDecoder.flush()) {\n        yield line;\n      }\n    }\n\n    async function* iterator(): AsyncIterator<Item, any, undefined> {\n      if (consumed) {\n        throw new Error('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n      }\n      consumed = true;\n      let done = false;\n      try {\n        for await (const line of iterLines()) {\n          if (done) continue;\n          if (line) yield JSON.parse(line);\n        }\n        done = true;\n      } catch (e) {\n        // If the user calls `stream.controller.abort()`, we should exit without throwing.\n        if (e instanceof Error && e.name === 'AbortError') return;\n        throw e;\n      } finally {\n        // If the user `break`s, abort the ongoing request.\n        if (!done) controller.abort();\n      }\n    }\n\n    return new Stream(iterator, controller);\n  }\n\n  [Symbol.asyncIterator](): AsyncIterator<Item> {\n    return this.iterator();\n  }\n\n  /**\n   * Splits the stream into two streams which can be\n   * independently read from at different speeds.\n   */\n  tee(): [Stream<Item>, Stream<Item>] {\n    const left: Array<Promise<IteratorResult<Item>>> = [];\n    const right: Array<Promise<IteratorResult<Item>>> = [];\n    const iterator = this.iterator();\n\n    const teeIterator = (queue: Array<Promise<IteratorResult<Item>>>): AsyncIterator<Item> => {\n      return {\n        next: () => {\n          if (queue.length === 0) {\n            const result = iterator.next();\n            left.push(result);\n            right.push(result);\n          }\n          return queue.shift()!;\n        },\n      };\n    };\n\n    return [\n      new Stream(() => teeIterator(left), this.controller),\n      new Stream(() => teeIterator(right), this.controller),\n    ];\n  }\n\n  /**\n   * Converts this stream to a newline-separated ReadableStream of\n   * JSON stringified values in the stream\n   * which can be turned back into a Stream with `Stream.fromReadableStream()`.\n   */\n  toReadableStream(): ReadableStream {\n    const self = this;\n    let iter: AsyncIterator<Item>;\n    const encoder = new TextEncoder();\n\n    return new ReadableStream({\n      async start() {\n        iter = self[Symbol.asyncIterator]();\n      },\n      async pull(ctrl: any) {\n        try {\n          const { value, done } = await iter.next();\n          if (done) return ctrl.close();\n\n          const bytes = encoder.encode(JSON.stringify(value) + '\\n');\n\n          ctrl.enqueue(bytes);\n        } catch (err) {\n          ctrl.error(err);\n        }\n      },\n      async cancel() {\n        await iter.return?.();\n      },\n    });\n  }\n}\n\nexport async function* _iterSSEMessages(\n  response: Response,\n  controller: AbortController,\n): AsyncGenerator<ServerSentEvent, void, unknown> {\n  if (!response.body) {\n    controller.abort();\n    throw new AnthropicError(`Attempted to iterate over a response with no body`);\n  }\n\n  const sseDecoder = new SSEDecoder();\n  const lineDecoder = new LineDecoder();\n\n  const iter = readableStreamAsyncIterable<Bytes>(response.body);\n  for await (const sseChunk of iterSSEChunks(iter)) {\n    for (const line of lineDecoder.decode(sseChunk)) {\n      const sse = sseDecoder.decode(line);\n      if (sse) yield sse;\n    }\n  }\n\n  for (const line of lineDecoder.flush()) {\n    const sse = sseDecoder.decode(line);\n    if (sse) yield sse;\n  }\n}\n\n/**\n * Given an async iterable iterator, iterates over it and yields full\n * SSE chunks, i.e. yields when a double new-line is encountered.\n */\nasync function* iterSSEChunks(iterator: AsyncIterableIterator<Bytes>): AsyncGenerator<Uint8Array> {\n  let data = new Uint8Array();\n\n  for await (const chunk of iterator) {\n    if (chunk == null) {\n      continue;\n    }\n\n    const binaryChunk =\n      chunk instanceof ArrayBuffer ? new Uint8Array(chunk)\n      : typeof chunk === 'string' ? new TextEncoder().encode(chunk)\n      : chunk;\n\n    let newData = new Uint8Array(data.length + binaryChunk.length);\n    newData.set(data);\n    newData.set(binaryChunk, data.length);\n    data = newData;\n\n    let patternIndex;\n    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {\n      yield data.slice(0, patternIndex);\n      data = data.slice(patternIndex);\n    }\n  }\n\n  if (data.length > 0) {\n    yield data;\n  }\n}\n\nfunction findDoubleNewlineIndex(buffer: Uint8Array): number {\n  // This function searches the buffer for the end patterns (\\r\\r, \\n\\n, \\r\\n\\r\\n)\n  // and returns the index right after the first occurrence of any pattern,\n  // or -1 if none of the patterns are found.\n  const newline = 0x0a; // \\n\n  const carriage = 0x0d; // \\r\n\n  for (let i = 0; i < buffer.length - 2; i++) {\n    if (buffer[i] === newline && buffer[i + 1] === newline) {\n      // \\n\\n\n      return i + 2;\n    }\n    if (buffer[i] === carriage && buffer[i + 1] === carriage) {\n      // \\r\\r\n      return i + 2;\n    }\n    if (\n      buffer[i] === carriage &&\n      buffer[i + 1] === newline &&\n      i + 3 < buffer.length &&\n      buffer[i + 2] === carriage &&\n      buffer[i + 3] === newline\n    ) {\n      // \\r\\n\\r\\n\n      return i + 4;\n    }\n  }\n\n  return -1;\n}\n\nclass SSEDecoder {\n  private data: string[];\n  private event: string | null;\n  private chunks: string[];\n\n  constructor() {\n    this.event = null;\n    this.data = [];\n    this.chunks = [];\n  }\n\n  decode(line: string) {\n    if (line.endsWith('\\r')) {\n      line = line.substring(0, line.length - 1);\n    }\n\n    if (!line) {\n      // empty line and we didn't previously encounter any messages\n      if (!this.event && !this.data.length) return null;\n\n      const sse: ServerSentEvent = {\n        event: this.event,\n        data: this.data.join('\\n'),\n        raw: this.chunks,\n      };\n\n      this.event = null;\n      this.data = [];\n      this.chunks = [];\n\n      return sse;\n    }\n\n    this.chunks.push(line);\n\n    if (line.startsWith(':')) {\n      return null;\n    }\n\n    let [fieldname, _, value] = partition(line, ':');\n\n    if (value.startsWith(' ')) {\n      value = value.substring(1);\n    }\n\n    if (fieldname === 'event') {\n      this.event = value;\n    } else if (fieldname === 'data') {\n      this.data.push(value);\n    }\n\n    return null;\n  }\n}\n\n/** This is an internal helper function that's just used for testing */\nexport function _decodeChunks(chunks: string[]): string[] {\n  const decoder = new LineDecoder();\n  const lines: string[] = [];\n  for (const chunk of chunks) {\n    lines.push(...decoder.decode(chunk));\n  }\n\n  return lines;\n}\n\nfunction partition(str: string, delimiter: string): [string, string, string] {\n  const index = str.indexOf(delimiter);\n  if (index !== -1) {\n    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\n  }\n\n  return [str, '', ''];\n}\n\n/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nexport function readableStreamAsyncIterable<T>(stream: any): AsyncIterableIterator<T> {\n  if (stream[Symbol.asyncIterator]) return stream;\n\n  const reader = stream.getReader();\n  return {\n    async next() {\n      try {\n        const result = await reader.read();\n        if (result?.done) reader.releaseLock(); // release lock when stream becomes closed\n        return result;\n      } catch (e) {\n        reader.releaseLock(); // release lock when stream becomes errored\n        throw e;\n      }\n    },\n    async return() {\n      const cancelPromise = reader.cancel();\n      reader.releaseLock();\n      await cancelPromise;\n      return { done: true, value: undefined };\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n"],"mappings":"SAASA,cAAc,QAAiB;SAC/BC,cAAc,QAAE;SAChBC,WAAW,QAAE;SAEbC,qBAAqB,QAAE;SACvBC,QAAQ,QAAE;AAUnB,OAAM,MAAOC,MAAM;EAGjBC,YACUC,QAAmC,EAC3CC,UAA2B;IADnB,KAAAD,QAAQ,GAARA,QAAQ;IAGhB,IAAI,CAACC,UAAU,GAAGA,UAAU;EAC9B;EAEA,OAAOC,eAAeA,CAAOC,QAAkB,EAAEF,UAA2B;IAC1E,IAAIG,QAAQ,GAAG,KAAK;IAEpB,gBAAgBJ,QAAQA,CAAA;MACtB,IAAII,QAAQ,EAAE;QACZ,MAAM,IAAIC,KAAK,CAAC,0EAA0E,CAAC;;MAE7FD,QAAQ,GAAG,IAAI;MACf,IAAIE,IAAI,GAAG,KAAK;MAChB,IAAI;QACF,WAAW,MAAMC,GAAG,IAAIC,gBAAgB,CAACL,QAAQ,EAAEF,UAAU,CAAC,EAAE;UAC9D,IAAIM,GAAG,CAACE,KAAK,KAAK,YAAY,EAAE;YAC9B,IAAI;cACF,MAAMC,IAAI,CAACC,KAAK,CAACJ,GAAG,CAACK,IAAI,CAAC;aAC3B,CAAC,OAAOC,CAAC,EAAE;cACVC,OAAO,CAACC,KAAK,CAAC,oCAAoC,EAAER,GAAG,CAACK,IAAI,CAAC;cAC7DE,OAAO,CAACC,KAAK,CAAC,aAAa,EAAER,GAAG,CAACS,GAAG,CAAC;cACrC,MAAMH,CAAC;;;UAIX,IACEN,GAAG,CAACE,KAAK,KAAK,eAAe,IAC7BF,GAAG,CAACE,KAAK,KAAK,eAAe,IAC7BF,GAAG,CAACE,KAAK,KAAK,cAAc,IAC5BF,GAAG,CAACE,KAAK,KAAK,qBAAqB,IACnCF,GAAG,CAACE,KAAK,KAAK,qBAAqB,IACnCF,GAAG,CAACE,KAAK,KAAK,oBAAoB,EAClC;YACA,IAAI;cACF,MAAMC,IAAI,CAACC,KAAK,CAACJ,GAAG,CAACK,IAAI,CAAC;aAC3B,CAAC,OAAOC,CAAC,EAAE;cACVC,OAAO,CAACC,KAAK,CAAC,oCAAoC,EAAER,GAAG,CAACK,IAAI,CAAC;cAC7DE,OAAO,CAACC,KAAK,CAAC,aAAa,EAAER,GAAG,CAACS,GAAG,CAAC;cACrC,MAAMH,CAAC;;;UAIX,IAAIN,GAAG,CAACE,KAAK,KAAK,MAAM,EAAE;YACxB;;UAGF,IAAIF,GAAG,CAACE,KAAK,KAAK,OAAO,EAAE;YACzB,MAAMZ,QAAQ,CAACoB,QAAQ,CACrBC,SAAS,EACT,cAAcX,GAAG,CAACK,IAAI,EAAE,EACxBL,GAAG,CAACK,IAAI,EACRhB,qBAAqB,CAACO,QAAQ,CAACgB,OAAO,CAAC,CACxC;;;QAGLb,IAAI,GAAG,IAAI;OACZ,CAAC,OAAOO,CAAC,EAAE;QACV;QACA,IAAIA,CAAC,YAAYR,KAAK,IAAIQ,CAAC,CAACO,IAAI,KAAK,YAAY,EAAE;QACnD,MAAMP,CAAC;OACR,SAAS;QACR;QACA,IAAI,CAACP,IAAI,EAAEL,UAAU,CAACoB,KAAK,EAAE;;IAEjC;IAEA,OAAO,IAAIvB,MAAM,CAACE,QAAQ,EAAEC,UAAU,CAAC;EACzC;EAEA;;;;EAIA,OAAOqB,kBAAkBA,CAAOC,cAA8B,EAAEtB,UAA2B;IACzF,IAAIG,QAAQ,GAAG,KAAK;IAEpB,gBAAgBoB,SAASA,CAAA;MACvB,MAAMC,WAAW,GAAG,IAAI9B,WAAW,EAAE;MAErC,MAAM+B,IAAI,GAAGC,2BAA2B,CAAQJ,cAAc,CAAC;MAC/D,WAAW,MAAMK,KAAK,IAAIF,IAAI,EAAE;QAC9B,KAAK,MAAMG,IAAI,IAAIJ,WAAW,CAACK,MAAM,CAACF,KAAK,CAAC,EAAE;UAC5C,MAAMC,IAAI;;;MAId,KAAK,MAAMA,IAAI,IAAIJ,WAAW,CAACM,KAAK,EAAE,EAAE;QACtC,MAAMF,IAAI;;IAEd;IAEA,gBAAgB7B,QAAQA,CAAA;MACtB,IAAII,QAAQ,EAAE;QACZ,MAAM,IAAIC,KAAK,CAAC,0EAA0E,CAAC;;MAE7FD,QAAQ,GAAG,IAAI;MACf,IAAIE,IAAI,GAAG,KAAK;MAChB,IAAI;QACF,WAAW,MAAMuB,IAAI,IAAIL,SAAS,EAAE,EAAE;UACpC,IAAIlB,IAAI,EAAE;UACV,IAAIuB,IAAI,EAAE,MAAMnB,IAAI,CAACC,KAAK,CAACkB,IAAI,CAAC;;QAElCvB,IAAI,GAAG,IAAI;OACZ,CAAC,OAAOO,CAAC,EAAE;QACV;QACA,IAAIA,CAAC,YAAYR,KAAK,IAAIQ,CAAC,CAACO,IAAI,KAAK,YAAY,EAAE;QACnD,MAAMP,CAAC;OACR,SAAS;QACR;QACA,IAAI,CAACP,IAAI,EAAEL,UAAU,CAACoB,KAAK,EAAE;;IAEjC;IAEA,OAAO,IAAIvB,MAAM,CAACE,QAAQ,EAAEC,UAAU,CAAC;EACzC;EAEA,CAAC+B,MAAM,CAACC,aAAa,IAAC;IACpB,OAAO,IAAI,CAACjC,QAAQ,EAAE;EACxB;EAEA;;;;EAIAkC,GAAGA,CAAA;IACD,MAAMC,IAAI,GAAyC,EAAE;IACrD,MAAMC,KAAK,GAAyC,EAAE;IACtD,MAAMpC,QAAQ,GAAG,IAAI,CAACA,QAAQ,EAAE;IAEhC,MAAMqC,WAAW,GAAIC,KAA2C,IAAyB;MACvF,OAAO;QACLC,IAAI,EAAEA,CAAA,KAAK;UACT,IAAID,KAAK,CAACE,MAAM,KAAK,CAAC,EAAE;YACtB,MAAMC,MAAM,GAAGzC,QAAQ,CAACuC,IAAI,EAAE;YAC9BJ,IAAI,CAACO,IAAI,CAACD,MAAM,CAAC;YACjBL,KAAK,CAACM,IAAI,CAACD,MAAM,CAAC;;UAEpB,OAAOH,KAAK,CAACK,KAAK,EAAG;QACvB;OACD;IACH,CAAC;IAED,OAAO,CACL,IAAI7C,MAAM,CAAC,MAAMuC,WAAW,CAACF,IAAI,CAAC,EAAE,IAAI,CAAClC,UAAU,CAAC,EACpD,IAAIH,MAAM,CAAC,MAAMuC,WAAW,CAACD,KAAK,CAAC,EAAE,IAAI,CAACnC,UAAU,CAAC,CACtD;EACH;EAEA;;;;;EAKA2C,gBAAgBA,CAAA;IACd,MAAMC,IAAI,GAAG,IAAI;IACjB,IAAInB,IAAyB;IAC7B,MAAMoB,OAAO,GAAG,IAAIC,WAAW,EAAE;IAEjC,OAAO,IAAItD,cAAc,CAAC;MACxB,MAAMuD,KAAKA,CAAA;QACTtB,IAAI,GAAGmB,IAAI,CAACb,MAAM,CAACC,aAAa,CAAC,EAAE;MACrC,CAAC;MACD,MAAMgB,IAAIA,CAACC,IAAS;QAClB,IAAI;UACF,MAAM;YAAEC,KAAK;YAAE7C;UAAI,CAAE,GAAG,MAAMoB,IAAI,CAACa,IAAI,EAAE;UACzC,IAAIjC,IAAI,EAAE,OAAO4C,IAAI,CAACE,KAAK,EAAE;UAE7B,MAAMC,KAAK,GAAGP,OAAO,CAACQ,MAAM,CAAC5C,IAAI,CAAC6C,SAAS,CAACJ,KAAK,CAAC,GAAG,IAAI,CAAC;UAE1DD,IAAI,CAACM,OAAO,CAACH,KAAK,CAAC;SACpB,CAAC,OAAOI,GAAG,EAAE;UACZP,IAAI,CAACnC,KAAK,CAAC0C,GAAG,CAAC;;MAEnB,CAAC;MACD,MAAMC,MAAMA,CAAA;QACV,MAAMhC,IAAI,CAACiC,MAAM,GAAE,CAAE;MACvB;KACD,CAAC;EACJ;;AAGF,OAAO,gBAAgBnD,gBAAgBA,CACrCL,QAAkB,EAClBF,UAA2B;EAE3B,IAAI,CAACE,QAAQ,CAACyD,IAAI,EAAE;IAClB3D,UAAU,CAACoB,KAAK,EAAE;IAClB,MAAM,IAAI3B,cAAc,CAAC,mDAAmD,CAAC;;EAG/E,MAAMmE,UAAU,GAAG,IAAIC,UAAU,EAAE;EACnC,MAAMrC,WAAW,GAAG,IAAI9B,WAAW,EAAE;EAErC,MAAM+B,IAAI,GAAGC,2BAA2B,CAAQxB,QAAQ,CAACyD,IAAI,CAAC;EAC9D,WAAW,MAAMG,QAAQ,IAAIC,aAAa,CAACtC,IAAI,CAAC,EAAE;IAChD,KAAK,MAAMG,IAAI,IAAIJ,WAAW,CAACK,MAAM,CAACiC,QAAQ,CAAC,EAAE;MAC/C,MAAMxD,GAAG,GAAGsD,UAAU,CAAC/B,MAAM,CAACD,IAAI,CAAC;MACnC,IAAItB,GAAG,EAAE,MAAMA,GAAG;;;EAItB,KAAK,MAAMsB,IAAI,IAAIJ,WAAW,CAACM,KAAK,EAAE,EAAE;IACtC,MAAMxB,GAAG,GAAGsD,UAAU,CAAC/B,MAAM,CAACD,IAAI,CAAC;IACnC,IAAItB,GAAG,EAAE,MAAMA,GAAG;;AAEtB;AAEA;;;;AAIA,gBAAgByD,aAAaA,CAAChE,QAAsC;EAClE,IAAIY,IAAI,GAAG,IAAIqD,UAAU,EAAE;EAE3B,WAAW,MAAMrC,KAAK,IAAI5B,QAAQ,EAAE;IAClC,IAAI4B,KAAK,IAAI,IAAI,EAAE;MACjB;;IAGF,MAAMsC,WAAW,GACftC,KAAK,YAAYuC,WAAW,GAAG,IAAIF,UAAU,CAACrC,KAAK,CAAC,GAClD,OAAOA,KAAK,KAAK,QAAQ,GAAG,IAAImB,WAAW,EAAE,CAACO,MAAM,CAAC1B,KAAK,CAAC,GAC3DA,KAAK;IAET,IAAIwC,OAAO,GAAG,IAAIH,UAAU,CAACrD,IAAI,CAAC4B,MAAM,GAAG0B,WAAW,CAAC1B,MAAM,CAAC;IAC9D4B,OAAO,CAACC,GAAG,CAACzD,IAAI,CAAC;IACjBwD,OAAO,CAACC,GAAG,CAACH,WAAW,EAAEtD,IAAI,CAAC4B,MAAM,CAAC;IACrC5B,IAAI,GAAGwD,OAAO;IAEd,IAAIE,YAAY;IAChB,OAAO,CAACA,YAAY,GAAGC,sBAAsB,CAAC3D,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE;MAC3D,MAAMA,IAAI,CAAC4D,KAAK,CAAC,CAAC,EAAEF,YAAY,CAAC;MACjC1D,IAAI,GAAGA,IAAI,CAAC4D,KAAK,CAACF,YAAY,CAAC;;;EAInC,IAAI1D,IAAI,CAAC4B,MAAM,GAAG,CAAC,EAAE;IACnB,MAAM5B,IAAI;;AAEd;AAEA,SAAS2D,sBAAsBA,CAACE,MAAkB;EAChD;EACA;EACA;EACA,MAAMC,OAAO,GAAG,IAAI,CAAC,CAAC;EACtB,MAAMC,QAAQ,GAAG,IAAI,CAAC,CAAC;EAEvB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,MAAM,CAACjC,MAAM,GAAG,CAAC,EAAEoC,CAAC,EAAE,EAAE;IAC1C,IAAIH,MAAM,CAACG,CAAC,CAAC,KAAKF,OAAO,IAAID,MAAM,CAACG,CAAC,GAAG,CAAC,CAAC,KAAKF,OAAO,EAAE;MACtD;MACA,OAAOE,CAAC,GAAG,CAAC;;IAEd,IAAIH,MAAM,CAACG,CAAC,CAAC,KAAKD,QAAQ,IAAIF,MAAM,CAACG,CAAC,GAAG,CAAC,CAAC,KAAKD,QAAQ,EAAE;MACxD;MACA,OAAOC,CAAC,GAAG,CAAC;;IAEd,IACEH,MAAM,CAACG,CAAC,CAAC,KAAKD,QAAQ,IACtBF,MAAM,CAACG,CAAC,GAAG,CAAC,CAAC,KAAKF,OAAO,IACzBE,CAAC,GAAG,CAAC,GAAGH,MAAM,CAACjC,MAAM,IACrBiC,MAAM,CAACG,CAAC,GAAG,CAAC,CAAC,KAAKD,QAAQ,IAC1BF,MAAM,CAACG,CAAC,GAAG,CAAC,CAAC,KAAKF,OAAO,EACzB;MACA;MACA,OAAOE,CAAC,GAAG,CAAC;;;EAIhB,OAAO,CAAC,CAAC;AACX;AAEA,MAAMd,UAAU;EAKd/D,YAAA;IACE,IAAI,CAACU,KAAK,GAAG,IAAI;IACjB,IAAI,CAACG,IAAI,GAAG,EAAE;IACd,IAAI,CAACiE,MAAM,GAAG,EAAE;EAClB;EAEA/C,MAAMA,CAACD,IAAY;IACjB,IAAIA,IAAI,CAACiD,QAAQ,CAAC,IAAI,CAAC,EAAE;MACvBjD,IAAI,GAAGA,IAAI,CAACkD,SAAS,CAAC,CAAC,EAAElD,IAAI,CAACW,MAAM,GAAG,CAAC,CAAC;;IAG3C,IAAI,CAACX,IAAI,EAAE;MACT;MACA,IAAI,CAAC,IAAI,CAACpB,KAAK,IAAI,CAAC,IAAI,CAACG,IAAI,CAAC4B,MAAM,EAAE,OAAO,IAAI;MAEjD,MAAMjC,GAAG,GAAoB;QAC3BE,KAAK,EAAE,IAAI,CAACA,KAAK;QACjBG,IAAI,EAAE,IAAI,CAACA,IAAI,CAACoE,IAAI,CAAC,IAAI,CAAC;QAC1BhE,GAAG,EAAE,IAAI,CAAC6D;OACX;MAED,IAAI,CAACpE,KAAK,GAAG,IAAI;MACjB,IAAI,CAACG,IAAI,GAAG,EAAE;MACd,IAAI,CAACiE,MAAM,GAAG,EAAE;MAEhB,OAAOtE,GAAG;;IAGZ,IAAI,CAACsE,MAAM,CAACnC,IAAI,CAACb,IAAI,CAAC;IAEtB,IAAIA,IAAI,CAACoD,UAAU,CAAC,GAAG,CAAC,EAAE;MACxB,OAAO,IAAI;;IAGb,IAAI,CAACC,SAAS,EAAEC,CAAC,EAAEhC,KAAK,CAAC,GAAGiC,SAAS,CAACvD,IAAI,EAAE,GAAG,CAAC;IAEhD,IAAIsB,KAAK,CAAC8B,UAAU,CAAC,GAAG,CAAC,EAAE;MACzB9B,KAAK,GAAGA,KAAK,CAAC4B,SAAS,CAAC,CAAC,CAAC;;IAG5B,IAAIG,SAAS,KAAK,OAAO,EAAE;MACzB,IAAI,CAACzE,KAAK,GAAG0C,KAAK;KACnB,MAAM,IAAI+B,SAAS,KAAK,MAAM,EAAE;MAC/B,IAAI,CAACtE,IAAI,CAAC8B,IAAI,CAACS,KAAK,CAAC;;IAGvB,OAAO,IAAI;EACb;;AAGF;AACA,OAAM,SAAUkC,aAAaA,CAACR,MAAgB;EAC5C,MAAMS,OAAO,GAAG,IAAI3F,WAAW,EAAE;EACjC,MAAM4F,KAAK,GAAa,EAAE;EAC1B,KAAK,MAAM3D,KAAK,IAAIiD,MAAM,EAAE;IAC1BU,KAAK,CAAC7C,IAAI,CAAC,GAAG4C,OAAO,CAACxD,MAAM,CAACF,KAAK,CAAC,CAAC;;EAGtC,OAAO2D,KAAK;AACd;AAEA,SAASH,SAASA,CAACI,GAAW,EAAEC,SAAiB;EAC/C,MAAMC,KAAK,GAAGF,GAAG,CAACG,OAAO,CAACF,SAAS,CAAC;EACpC,IAAIC,KAAK,KAAK,CAAC,CAAC,EAAE;IAChB,OAAO,CAACF,GAAG,CAACT,SAAS,CAAC,CAAC,EAAEW,KAAK,CAAC,EAAED,SAAS,EAAED,GAAG,CAACT,SAAS,CAACW,KAAK,GAAGD,SAAS,CAACjD,MAAM,CAAC,CAAC;;EAGtF,OAAO,CAACgD,GAAG,EAAE,EAAE,EAAE,EAAE,CAAC;AACtB;AAEA;;;;;;AAMA,OAAM,SAAU7D,2BAA2BA,CAAIiE,MAAW;EACxD,IAAIA,MAAM,CAAC5D,MAAM,CAACC,aAAa,CAAC,EAAE,OAAO2D,MAAM;EAE/C,MAAMC,MAAM,GAAGD,MAAM,CAACE,SAAS,EAAE;EACjC,OAAO;IACL,MAAMvD,IAAIA,CAAA;MACR,IAAI;QACF,MAAME,MAAM,GAAG,MAAMoD,MAAM,CAACE,IAAI,EAAE;QAClC,IAAItD,MAAM,EAAEnC,IAAI,EAAEuF,MAAM,CAACG,WAAW,EAAE,CAAC,CAAC;QACxC,OAAOvD,MAAM;OACd,CAAC,OAAO5B,CAAC,EAAE;QACVgF,MAAM,CAACG,WAAW,EAAE,CAAC,CAAC;QACtB,MAAMnF,CAAC;;IAEX,CAAC;IACD,MAAM8C,MAAMA,CAAA;MACV,MAAMsC,aAAa,GAAGJ,MAAM,CAACnC,MAAM,EAAE;MACrCmC,MAAM,CAACG,WAAW,EAAE;MACpB,MAAMC,aAAa;MACnB,OAAO;QAAE3F,IAAI,EAAE,IAAI;QAAE6C,KAAK,EAAEjC;MAAS,CAAE;IACzC,CAAC;IACD,CAACc,MAAM,CAACC,aAAa,IAAC;MACpB,OAAO,IAAI;IACb;GACD;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
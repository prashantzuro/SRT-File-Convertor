{"ast":null,"code":"async function translateSrt(fileContent, language, apiKey) {\n  console.log(\"Sending translation request...\");\n  let retryDelay = 2000; // Initial delay (2 seconds)\n  const maxRetries = 5; // Maximum number of retries\n  let retryCount = 0;\n  try {\n    var _data$choices$, _data$choices$$messag;\n    let response;\n\n    // Loop for retrying in case of rate limit\n    do {\n      response = await fetch(\"https://api.openai.com/v1/chat/completions\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"Authorization\": `Bearer ${apiKey}`\n        },\n        body: JSON.stringify({\n          model: \"gpt-3.5-turbo\",\n          // Adjust to your model\n          messages: [{\n            role: \"system\",\n            content: \"Translate the SRT file content.\"\n          }, {\n            role: \"user\",\n            content: fileContent\n          }, {\n            role: \"user\",\n            content: `Translate to: ${language}`\n          }]\n        })\n      });\n      if (!response.ok) {\n        if (response.status === 429 && retryCount < maxRetries) {\n          // If rate limit is hit, wait and retry\n          console.warn(`Rate limit hit. Retrying in ${retryDelay / 1000} seconds...`);\n          await new Promise(resolve => setTimeout(resolve, retryDelay));\n          retryDelay *= 2; // Exponentially increase the delay\n          retryCount++;\n        } else {\n          // If error other than rate limit or max retries reached, throw error\n          const errorData = await response.json();\n          console.error(\"API Error:\", errorData);\n          throw new Error(`API request failed with status ${response.status}`);\n        }\n      }\n    } while (response.status === 429 && retryCount < maxRetries);\n\n    // If we exceed the maximum retries, throw an error\n    if (response.status === 429) {\n      throw new Error(\"Max retries exceeded for rate limit.\");\n    }\n\n    // Process the translation result if response is okay\n    const data = await response.json();\n    const translatedText = ((_data$choices$ = data.choices[0]) === null || _data$choices$ === void 0 ? void 0 : (_data$choices$$messag = _data$choices$.message) === null || _data$choices$$messag === void 0 ? void 0 : _data$choices$$messag.content) || \"\";\n    if (!translatedText) {\n      throw new Error(\"Empty translation result.\");\n    }\n    return translatedText;\n  } catch (error) {\n    console.error(\"Translation Error:\", error);\n    throw error; // Re-throw the error to be handled by calling function\n  }\n}","map":{"version":3,"names":["translateSrt","fileContent","language","apiKey","console","log","retryDelay","maxRetries","retryCount","_data$choices$","_data$choices$$messag","response","fetch","method","headers","body","JSON","stringify","model","messages","role","content","ok","status","warn","Promise","resolve","setTimeout","errorData","json","error","Error","data","translatedText","choices","message"],"sources":["/home/user/srt-translator/src/utils/translateSrt.ts"],"sourcesContent":["async function translateSrt(fileContent: string, language: string, apiKey: string) {\n  console.log(\"Sending translation request...\");\n\n  let retryDelay = 2000; // Initial delay (2 seconds)\n  const maxRetries = 5; // Maximum number of retries\n  let retryCount = 0;\n\n  try {\n    let response;\n\n    // Loop for retrying in case of rate limit\n    do {\n      response = await fetch(\"https://api.openai.com/v1/chat/completions\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"Authorization\": `Bearer ${apiKey}`,\n        },\n        body: JSON.stringify({\n          model: \"gpt-3.5-turbo\",  // Adjust to your model\n          messages: [\n            { role: \"system\", content: \"Translate the SRT file content.\" },\n            { role: \"user\", content: fileContent },\n            { role: \"user\", content: `Translate to: ${language}` },\n          ],\n        }),\n      });\n\n      if (!response.ok) {\n        if (response.status === 429 && retryCount < maxRetries) {\n          // If rate limit is hit, wait and retry\n          console.warn(`Rate limit hit. Retrying in ${retryDelay / 1000} seconds...`);\n          await new Promise(resolve => setTimeout(resolve, retryDelay));\n          retryDelay *= 2;  // Exponentially increase the delay\n          retryCount++;\n        } else {\n          // If error other than rate limit or max retries reached, throw error\n          const errorData = await response.json();\n          console.error(\"API Error:\", errorData);\n          throw new Error(`API request failed with status ${response.status}`);\n        }\n      }\n    } while (response.status === 429 && retryCount < maxRetries);\n\n    // If we exceed the maximum retries, throw an error\n    if (response.status === 429) {\n      throw new Error(\"Max retries exceeded for rate limit.\");\n    }\n\n    // Process the translation result if response is okay\n    const data = await response.json();\n    const translatedText = data.choices[0]?.message?.content || \"\";\n\n    if (!translatedText) {\n      throw new Error(\"Empty translation result.\");\n    }\n\n    return translatedText;\n  } catch (error) {\n    console.error(\"Translation Error:\", error);\n    throw error;  // Re-throw the error to be handled by calling function\n  }\n}\n"],"mappings":"AAAA,eAAeA,YAAYA,CAACC,WAAmB,EAAEC,QAAgB,EAAEC,MAAc,EAAE;EACjFC,OAAO,CAACC,GAAG,CAAC,gCAAgC,CAAC;EAE7C,IAAIC,UAAU,GAAG,IAAI,CAAC,CAAC;EACvB,MAAMC,UAAU,GAAG,CAAC,CAAC,CAAC;EACtB,IAAIC,UAAU,GAAG,CAAC;EAElB,IAAI;IAAA,IAAAC,cAAA,EAAAC,qBAAA;IACF,IAAIC,QAAQ;;IAEZ;IACA,GAAG;MACDA,QAAQ,GAAG,MAAMC,KAAK,CAAC,4CAA4C,EAAE;QACnEC,MAAM,EAAE,MAAM;QACdC,OAAO,EAAE;UACP,cAAc,EAAE,kBAAkB;UAClC,eAAe,EAAE,UAAUX,MAAM;QACnC,CAAC;QACDY,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;UACnBC,KAAK,EAAE,eAAe;UAAG;UACzBC,QAAQ,EAAE,CACR;YAAEC,IAAI,EAAE,QAAQ;YAAEC,OAAO,EAAE;UAAkC,CAAC,EAC9D;YAAED,IAAI,EAAE,MAAM;YAAEC,OAAO,EAAEpB;UAAY,CAAC,EACtC;YAAEmB,IAAI,EAAE,MAAM;YAAEC,OAAO,EAAE,iBAAiBnB,QAAQ;UAAG,CAAC;QAE1D,CAAC;MACH,CAAC,CAAC;MAEF,IAAI,CAACS,QAAQ,CAACW,EAAE,EAAE;QAChB,IAAIX,QAAQ,CAACY,MAAM,KAAK,GAAG,IAAIf,UAAU,GAAGD,UAAU,EAAE;UACtD;UACAH,OAAO,CAACoB,IAAI,CAAC,+BAA+BlB,UAAU,GAAG,IAAI,aAAa,CAAC;UAC3E,MAAM,IAAImB,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAEpB,UAAU,CAAC,CAAC;UAC7DA,UAAU,IAAI,CAAC,CAAC,CAAE;UAClBE,UAAU,EAAE;QACd,CAAC,MAAM;UACL;UACA,MAAMoB,SAAS,GAAG,MAAMjB,QAAQ,CAACkB,IAAI,CAAC,CAAC;UACvCzB,OAAO,CAAC0B,KAAK,CAAC,YAAY,EAAEF,SAAS,CAAC;UACtC,MAAM,IAAIG,KAAK,CAAC,kCAAkCpB,QAAQ,CAACY,MAAM,EAAE,CAAC;QACtE;MACF;IACF,CAAC,QAAQZ,QAAQ,CAACY,MAAM,KAAK,GAAG,IAAIf,UAAU,GAAGD,UAAU;;IAE3D;IACA,IAAII,QAAQ,CAACY,MAAM,KAAK,GAAG,EAAE;MAC3B,MAAM,IAAIQ,KAAK,CAAC,sCAAsC,CAAC;IACzD;;IAEA;IACA,MAAMC,IAAI,GAAG,MAAMrB,QAAQ,CAACkB,IAAI,CAAC,CAAC;IAClC,MAAMI,cAAc,GAAG,EAAAxB,cAAA,GAAAuB,IAAI,CAACE,OAAO,CAAC,CAAC,CAAC,cAAAzB,cAAA,wBAAAC,qBAAA,GAAfD,cAAA,CAAiB0B,OAAO,cAAAzB,qBAAA,uBAAxBA,qBAAA,CAA0BW,OAAO,KAAI,EAAE;IAE9D,IAAI,CAACY,cAAc,EAAE;MACnB,MAAM,IAAIF,KAAK,CAAC,2BAA2B,CAAC;IAC9C;IAEA,OAAOE,cAAc;EACvB,CAAC,CAAC,OAAOH,KAAK,EAAE;IACd1B,OAAO,CAAC0B,KAAK,CAAC,oBAAoB,EAAEA,KAAK,CAAC;IAC1C,MAAMA,KAAK,CAAC,CAAE;EAChB;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}